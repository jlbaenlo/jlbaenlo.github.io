<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <title>Triateur de Playlists (V0 - Clean Rewrite)</title>
    <!-- External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>

    <style>
        :root {
            --spotify-green: #1DB954;
            --spotify-black: #191414;
            --light-grey: #f5f5f5;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--light-grey);
            color: #333;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            background: white;
            max-width: 900px;
            width: 100%;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: var(--spotify-green);
            text-align: center;
            margin-bottom: 10px;
        }

        .version {
            font-size: 0.6em;
            color: #666;
            vertical-align: middle;
        }

        /* Steps */
        .step {
            margin-bottom: 30px;
            padding: 20px;
            border-left: 4px solid var(--spotify-green);
            background: #fafafa;
            border-radius: 0 8px 8px 0;
        }

        .hidden {
            display: none;
        }

        /* Buttons */
        .btn {
            background-color: var(--spotify-green);
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 30px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.2s;
            text-decoration: none;
            display: inline-block;
        }

        .btn:hover {
            background-color: #1ed760;
            transform: scale(1.02);
        }

        .btn-secondary {
            background-color: #555;
        }

        /* Inputs */
        input[type="file"] {
            border: 2px dashed #ccc;
            padding: 20px;
            width: 100%;
            box-sizing: border-box;
            text-align: center;
            cursor: pointer;
        }

        /* Graph Container */
        .graph-container {
            position: relative;
            height: 400px;
            width: 100%;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: white;
            margin-top: 20px;
        }

        /* Table */
        .table-responsive {
            overflow-x: auto;
            margin-top: 20px;
        }

        table {
            width: auto;
            min-width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
        }

        th,
        td {
            padding: 10px;
            border-bottom: 1px solid #eee;
            text-align: left;
            white-space: nowrap !important;
        }

        th {
            background-color: #f8f8f8;
        }

        /* Debug Box */
        #debug-log {
            font-family: monospace;
            font-size: 12px;
            background: #333;
            color: #0f0;
            padding: 10px;
            border-radius: 4px;
            margin-top: 20px;
            max-height: 150px;
            overflow-y: auto;
            display: none;
            /* Hidden by default */
        }
    </style>
</head>

<body>

    <div class="container">
        <h1>Triateur de Playlists ü™© <span class="version">(V1 - Advanced)</span></h1>

        <div style="text-align: center; margin-bottom: 20px;">
            <button onclick="window.location.reload()" class="btn btn-secondary"
                style="font-size: 0.8em; padding: 5px 15px;">
                ‚Üª Recharger l'app
            </button>
        </div>

        <!-- DEBUG LOG -->
        <div id="debug-log">Log system initiated...</div>

        <!-- STEP 1: IMPORT -->
        <div id="step-import" class="step">
            <h2>1. Import (CSV)</h2>
            <p>Exportez votre playlist depuis <a href="https://exportify.net" target="_blank">Exportify.net</a> (Format
                CSV) et glissez-la ici.</p>
            <input type="file" id="csvInput" accept=".csv" />
            <p id="import-status" style="margin-top: 10px; font-weight: bold;"></p>
        </div>

        <!-- STATS SECTION -->
        <div id="stats-section" class="hidden" style="margin-bottom: 30px; animation: fadeIn 0.5s;">
            <h3 style="border-bottom: 2px solid #eee; padding-bottom: 10px;">üìä Analyse de la Playlist</h3>

            <div style="display: flex; gap: 20px; flex-wrap: wrap; margin-bottom: 20px;">
                <div
                    style="flex: 1; min-width: 300px; height: 300px; padding: 10px; background: #fafafa; border-radius: 8px;">
                    <canvas id="genreChart"></canvas>
                </div>
                <div
                    style="flex: 1; min-width: 300px; height: 300px; padding: 10px; background: #fafafa; border-radius: 8px;">
                    <canvas id="criteriaChart"></canvas>
                </div>
            </div>
        </div>

        <!-- STEP 2: CONFIG & GRAPH -->
        <div id="step-config" class="step hidden">
            <h2>2. Design Your Flow üåä</h2>

            <div style="background: #eee; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                <div style="display: flex; gap: 20px; align-items: flex-end; flex-wrap: wrap;">
                    <!-- Time Controls -->
                    <div>
                        <label style="font-size:12px; font-weight:bold;">D√©but</label><br>
                        <input type="time" id="startTime" value="21:00"
                            style="padding: 5px; border:1px solid #ccc; border-radius:4px;">
                    </div>
                    <div>
                        <label style="font-size:12px; font-weight:bold;">Fin</label><br>
                        <input type="time" id="endTime" value="23:00"
                            style="padding: 5px; border:1px solid #ccc; border-radius:4px;">
                    </div>
                    <div style="font-size: 14px; font-weight: bold; color: var(--spotify-green); padding-bottom: 5px;">
                        Dur√©e: <span id="totalDurationLabel">2h 00m</span>
                    </div>

                    <!-- Preset Selector -->
                    <div style="margin-left: auto;">
                        <label style="font-size:12px; font-weight:bold;">Mode</label><br>
                        <select id="flowMode" style="padding: 6px; border-radius:4px; min-width: 120px;">
                            <option value="custom">üõ†Ô∏è Custom</option>
                            <option value="party" selected>üéâ Party (Standard)</option>
                            <option value="apero">üç∑ Ap√©ro (Chill)</option>
                            <option value="sport">üí™ Sport (Intensity)</option>
                        </select>
                    </div>

                    <div>
                        <label style="font-size:12px; font-weight:bold;">Phases</label><br>
                        <input type="number" id="numPhases" value="5" min="2" max="10"
                            style="width: 50px; padding: 5px;">
                    </div>

                    <button id="resetGraphBtn" class="btn btn-secondary"
                        style="padding: 6px 12px; font-size: 12px;">Reset</button>

                </div>
                <!-- Advanced Constraints -->
                <div style="margin-top: 10px; border-top: 1px solid #ccc; padding-top: 10px;">
                    <label style="font-size: 13px; display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="genreCohesion" checked>
                        <span><b>Coh√©sion de Genre:</b> Grouper 2 √† 3 musiques du m√™me style √† la suite (si
                            possible).</span>
                    </label>
                    <label style="font-size: 13px; display: flex; align-items: center; gap: 8px; margin-top: 5px;">
                        <input type="checkbox" id="harmonicMixing" checked>
                        <span><b>Harmonic Mixing:</b> Favoriser les transitions harmoniques (Camelot Wheel).</span>
                    </label>
                </div>
            </div>

            <p class="small" style="margin-bottom: 5px;">
                üñ±Ô∏è <b>Drag</b> les points pour l'intensit√©. ‚ÜîÔ∏è <b>Drag</b> les lignes verticales pour changer la dur√©e.
            </p>
            <div class="graph-container">
                <canvas id="flowChart"></canvas>
            </div>
            <div
                style="display: flex; justify-content: center; gap: 15px; font-size: 13px; margin-top: 5px; flex-wrap: wrap;">
                <span style="color:rgba(255, 99, 132, 1)">‚óè Energy</span>
                <span style="color:rgba(54, 162, 235, 1)">‚óè Dance</span>
                <span style="color:rgba(75, 192, 192, 1)">‚óè Valence</span>
                <span style="color:rgba(255, 206, 86, 1)">‚óè Tempo</span>
            </div>

            <!-- Algorithm Explanation -->
            <div style="text-align: center; margin-top: 20px;">
                <button onclick="document.getElementById('algoInfo').classList.toggle('hidden')"
                    class="btn btn-secondary" style="font-size: 12px; padding: 5px 10px;">
                    ‚ÑπÔ∏è Comprendre l'Algorithme
                </button>

                <div id="algoInfo" class="hidden"
                    style="text-align: left; background: #f9f9f9; padding: 15px; border-radius: 8px; margin-top: 10px; font-size: 0.9em; border: 1px solid #ddd;">

                    <h4 style="margin-top:0;">1. Normalisation Intelligente</h4>
                    <p>Le syst√®me standardise toutes les donn√©es :</p>
                    <ul>
                        <li><b>Crit√®res (0-1):</b> Energy, Dance, Valence sont recalibr√©s sur la m√™me √©chelle.</li>
                        <li><b>Tempo Relatif:</b> 0% correspond √† votre titre le plus lent, 100% au plus rapide.</li>
                        <li><b>Cl√© Musicale:</b> Chaque titre est analys√© pour d√©terminer sa cl√© Camelot (ex: 8A, 5B).
                        </li>
                    </ul>

                    <h4>2. C≈ìur de l'Algo : Distance Math√©matique</h4>
                    <p>Pour chaque moment du set, on cherche le titre qui minimise l'√©cart avec votre courbe cible :</p>
                    <code
                        style="display:block; background:#333; color:#fff; padding:10px; border-radius:4px; margin: 5px 0; font-size: 0.85em;">
                        Score = ‚àö [ (ŒîEnergy)¬≤ + (ŒîDance)¬≤ + (ŒîValence)¬≤ + (ŒîTempo)¬≤ ]
                    </code>

                    <h4>3. Contraintes Avanc√©es (Bonus/Malus)</h4>
                    <p>Si activ√©es, ces options modifient le Score pour influencer le choix :</p>

                    <div style="background: #eef; padding: 8px; border-radius: 4px; margin-bottom: 5px;">
                        <b>üß¨ Coh√©sion de Genre :</b>
                        <ul style="margin:5px 0; padding-left:20px;">
                            <li><b>But :</b> Cr√©er des "mini-sets" de 2 √† 4 titres du m√™me style pour √©viter l'effet
                                "Jukebox al√©atoire".</li>
                            <li><b>M√©canique :</b>
                                <ul>
                                    <li>Si on continue le m√™me genre : <b>Bonus (-0.1)</b> (pousse √† continuer).</li>
                                    <li>Si on change de genre trop t√¥t (< 2 titres) : <b>Malus (+2.0)</b> (√©vite le
                                            zapping).</li>
                                    <li>Si le m√™me genre dure trop longtemps (> 4 titres) : <b>Gros Malus (+10.0)</b>
                                        (force le changement).</li>
                                </ul>
                            </li>
                        </ul>
                    </div>

                    <div style="background: #efe; padding: 8px; border-radius: 4px;">
                        <b>üéπ Harmonic Mixing (Camelot) :</b>
                        <ul style="margin:5px 0; padding-left:20px;">
                            <li><b>But :</b> Des transitions fluides et musicales qui ne "heurtent" pas l'oreille.</li>
                            <li><b>M√©canique :</b>
                                <ul>
                                    <li><b>Compatible :</b> Cl√© identique (8A‚Üí8A), Adjacente (8A‚Üí9A/7A), ou Swap
                                        (8A‚Üí8B).</li>
                                    <li><b>Bonus (-0.2) :</b> Appliqu√© aux titres harmoniquement compatibles.</li>
                                    <li><b>Malus (+0.5) :</b> Appliqu√© aux titres dissonants.</li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>

            <div style="text-align: center; margin-top: 20px;">
                <button id="generateBtn" class="btn">üöÄ G√©n√©rer la Playlist</button>
            </div>
        </div>

        <!-- STEP 3: RESULTS -->
        <div id="step-results" class="step hidden">
            <h2>3. R√©sultats</h2>
            <p id="result-summary"></p>
            <button id="downloadBtn" class="btn">üì• T√©l√©charger le CSV tri√©</button>
            <button id="spotifyExportBtn" class="btn hidden"
                style="background-color: #1DB954; color: white; border: none; margin-left: 10px;">üü¢ Exporter vers
                Spotify</button>

            <!-- Result Chart Integration -->
            <div class="container"
                style="margin-top: 20px; padding: 15px; background: #fff; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                <header style="text-align: center; margin-bottom: 10px;">
                    <h3 style="margin: 0; color: #333;">Architecture √ânerg√©tique du Set</h3>
                    <p style="color: #666; font-size: 0.9em; margin: 0;">Corr√©lation entre Danceability, Energy, Valence
                        et Tempo</p>
                </header>
                <div style="position: relative; height: 350px; width: 100%;">
                    <canvas id="resultChart"></canvas>
                </div>
            </div>

            <div class="table-responsive">
                <table id="resultTable">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Titre</th>
                            <th>Artiste</th>
                            <th>BPM</th>
                            <th>Energy</th>
                            <th>Dance</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

    </div>

    <!-- CUSTOM MODAL -->
    <div id="appModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 id="modalTitle">Titre</h3>
            <p id="modalDesc">Description</p>

            <!-- Input container -->
            <div id="modalInputContainer" class="hidden">
                <input type="text" id="modalInput"
                    style="width: 100%; padding: 10px; font-size: 16px; border: 1px solid #ddd; border-radius: 4px; margin: 10px 0;">
            </div>

            <!-- Actions -->
            <div class="modal-actions"
                style="margin-top: 20px; text-align: right; display: flex; gap: 10px; justify-content: flex-end;">
                <button id="modalCancelBtn" class="btn btn-secondary">Annuler</button>
                <button id="modalConfirmBtn" class="btn">Valider</button>
            </div>
        </div>
    </div>

    <style>
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: white;
            padding: 25px;
            border-radius: 12px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            animation: fadeIn 0.2s ease-out;
        }

        .modal-overlay.hidden {
            display: none;
        }
    </style>

    <!-- MAIN SCRIPT -->
    <script>
        // --- MODAL HELPERS ---
        const modal = document.getElementById('appModal');
        const mTitle = document.getElementById('modalTitle');
        const mDesc = document.getElementById('modalDesc');
        const mInputDiv = document.getElementById('modalInputContainer');
        const mInput = document.getElementById('modalInput');
        const mActions = document.getElementById('modalActions'); // Need to target this to swap content

        // We'll create dynamic buttons to ensure clean state
        function resetModalButtons() {
            const oldConfirm = document.getElementById('modalConfirmBtn');
            const oldCancel = document.getElementById('modalCancelBtn');
            // Clone to strip listeners
            const newConfirm = oldConfirm.cloneNode(true);
            const newCancel = oldCancel.cloneNode(true);
            oldConfirm.parentNode.replaceChild(newConfirm, oldConfirm);
            oldCancel.parentNode.replaceChild(newCancel, oldCancel);
            return { confirm: newConfirm, cancel: newCancel };
        }

        function showInputModal(title, msg, defaultValue) {
            return new Promise((resolve) => {
                mTitle.textContent = title;
                mDesc.textContent = msg;
                mInput.value = defaultValue;
                mInputDiv.classList.remove('hidden');

                // Buttons
                const btns = resetModalButtons();
                btns.confirm.textContent = "Valider";
                btns.confirm.style.display = 'inline-block';
                btns.cancel.style.display = 'inline-block';
                btns.cancel.onclick = () => { closeModal(); resolve(null); };
                btns.confirm.onclick = () => { closeModal(); resolve(mInput.value); };

                modal.classList.remove('hidden');
                mInput.focus();
            });
        }

        function showLoadingModal(msg) {
            mTitle.textContent = "Veuillez patienter...";
            mDesc.textContent = msg;
            mInputDiv.classList.add('hidden');

            const btns = resetModalButtons();
            btns.confirm.style.display = 'none';
            btns.cancel.style.display = 'none'; // No cancel during loading

            modal.classList.remove('hidden');
        }

        function showSuccessModal(title, msg, linkUrl) {
            mTitle.textContent = title;
            mDesc.innerHTML = msg;
            mInputDiv.classList.add('hidden');

            const btns = resetModalButtons();
            btns.cancel.style.display = 'inline-block';
            btns.cancel.textContent = "Fermer";
            btns.cancel.onclick = closeModal;

            // Turn Confirm button into a Link-like trigger or just replace it
            btns.confirm.style.display = 'none'; // Hide standard button

            // Add custom Link Button if not exists
            let linkBtn = document.getElementById('modalLinkBtn');
            if (!linkBtn) {
                linkBtn = document.createElement('a');
                linkBtn.id = 'modalLinkBtn';
                linkBtn.className = 'btn';
                linkBtn.style.marginLeft = '10px';
                linkBtn.style.textDecoration = 'none';
                linkBtn.style.display = 'inline-block';
                btns.confirm.parentNode.appendChild(linkBtn);
            }
            linkBtn.style.display = 'inline-block';
            linkBtn.textContent = "Ouvrir Spotify ‚ÜóÔ∏è";
            linkBtn.href = linkUrl;
            linkBtn.target = "_blank";

            modal.classList.remove('hidden');
        }

        function closeModal() {
            modal.classList.add('hidden');
            // Hide link button if exists
            const linkBtn = document.getElementById('modalLinkBtn');
            if (linkBtn) linkBtn.style.display = 'none';
        }

        // --- UTILS ---
        const debugLog = document.getElementById('debug-log');
        function log(msg) {
            console.log(msg);
            debugLog.style.display = 'block';
            debugLog.innerHTML += `<div>> ${msg}</div>`;
            debugLog.scrollTop = debugLog.scrollHeight;
        }

        // --- SPOTIFY EXPORT LOGIC ---
        const CLIENT_ID_STORAGE_KEY = 'spotify_client_id';
        const ACCESS_TOKEN_KEY = 'spotify_access_token';
        const STATE_KEY = 'spotify_auth_state';
        const DEFAULT_CLIENT_ID = 'e37b29847db846ebbc8c6bfca9820c8d';

        // --- PKCE HELPERS ---
        function generateRandomString(length) {
            let text = '';
            const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            for (let i = 0; i < length; i++) {
                text += possible.charAt(Math.floor(Math.random() * possible.length));
            }
            return text;
        }

        async function generateCodeChallenge(codeVerifier) {
            const encoder = new TextEncoder();
            const data = encoder.encode(codeVerifier);
            const digest = await window.crypto.subtle.digest('SHA-256', data);
            return base64encode(digest);
        }

        function base64encode(string) {
            return btoa(String.fromCharCode.apply(null, new Uint8Array(string)))
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=+$/, '');
        }

        async function handleSpotifyExport(playlistTracks) {
            log("Initiating Spotify Export (PKCE)...");

            // 1. Prompt for Name FIRST (Using Custom Modal)
            const defaultName = `My Flow - ${new Date().toLocaleDateString()}`;
            const playlistName = await showInputModal("Export Spotify", "Nom de votre Playlist :", defaultName);

            if (!playlistName) {
                log("Export annul√© par l'utilisateur.");
                return;
            }

            // 2. Check for Token
            let token = localStorage.getItem(ACCESS_TOKEN_KEY);
            let tokenExpiry = localStorage.getItem('spotify_token_expiry');

            if (!token || (tokenExpiry && Date.now() > parseInt(tokenExpiry))) {
                // Auth Flow Needed
                log("Redirecting to Spotify Auth (PKCE)...");

                let clientId = DEFAULT_CLIENT_ID;
                const redirectUri = window.location.href.split('#')[0].split('?')[0];

                // Generate PKCE Verifier & Challenge
                const codeVerifier = generateRandomString(128);
                const codeChallenge = await generateCodeChallenge(codeVerifier);

                // Save State & Verifier
                const appState = {
                    rawTracks: rawTracks,
                    phases: phases,
                    startTime: document.getElementById('startTime').value,
                    endTime: document.getElementById('endTime').value,
                    mode: document.getElementById('flowMode').value,
                    pendingExportName: playlistName
                };
                localStorage.setItem(STATE_KEY, JSON.stringify(appState));
                localStorage.setItem('spotify_code_verifier', codeVerifier);

                const scope = 'playlist-modify-public playlist-modify-private';
                const authUrl = `https://accounts.spotify.com/authorize?response_type=code&client_id=${clientId}&scope=${encodeURIComponent(scope)}&redirect_uri=${encodeURIComponent(redirectUri)}&code_challenge_method=S256&code_challenge=${codeChallenge}`;

                window.location.href = authUrl;
                return;
            }

            // 3. We have a token - Proceed...
            try {
                // Get User Profile
                const userReq = await fetch('https://api.spotify.com/v1/me', { headers: { 'Authorization': `Bearer ${token}` } });
                if (userReq.status === 401) {
                    alert("Token expir√©. Veuillez r√©-exporter pour vous authentifier √† nouveau.");
                    localStorage.removeItem(ACCESS_TOKEN_KEY);
                    return;
                }
                const userData = await userReq.json();
                const userId = userData.id;

                // Create Playlist using PROMPTED Name
                const createReq = await fetch(`https://api.spotify.com/v1/users/${userId}/playlists`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name: playlistName,
                        description: "Generated by Playlist Sorter Flow",
                        public: false
                    })
                });
                const playlistData = await createReq.json();
                const playlistId = playlistData.id;

                // Add Tracks
                const uris = playlistTracks
                    .map(t => t['Track URI'])
                    .filter(uri => uri && uri.startsWith('spotify:track:'));

                if (uris.length === 0) {
                    alert("Aucun URI Spotify trouv√©. V√©rifiez votre CSV.");
                    return;
                }

                showLoadingModal(`Export en cours...<br>Ajout de ${uris.length} titres.`);

                // Batch requests
                for (let i = 0; i < uris.length; i += 100) {
                    const batch = uris.slice(i, i + 100);
                    await fetch(`https://api.spotify.com/v1/playlists/${playlistId}/tracks`, {
                        method: 'POST',
                        headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
                        body: JSON.stringify({ uris: batch })
                    });
                }

                // Success Handling (Custom Modal)
                log(`Playlist "${playlistName}" created!`);
                const resultSummary = document.getElementById('result-summary');
                resultSummary.innerHTML = `‚úÖ Playlist <b>"${playlistName}"</b> cr√©√©e ! <a href="${playlistData.external_urls.spotify}" target="_blank" style="color:#1DB954; font-weight:bold;">Ouvrir sur Spotify ‚ÜóÔ∏è</a><br>` + resultSummary.innerHTML;

                showSuccessModal(
                    "C'est fait ! üéâ",
                    `La playlist <b>"${playlistName}"</b> a √©t√© ajout√©e √† votre biblioth√®que.`,
                    playlistData.external_urls.spotify
                );

            } catch (e) {
                log("Spotify API Error: " + e.message);
                console.error(e);
                alert("Erreur: " + e.message);
            }
        }

        // --- GLOBAL STATE ---
        let rawTracks = [];
        // Phases State: { id, energy, dance, durationPercent, startPercent }
        // Note: startPercent is derived from durationPercent of previous items.
        // It is easier to store `durationPercent` as the source of truth.
        let phases = [];
        let totalTimeMinutes = 120; // Default 2h

        // --- INITIALIZATION ---
        window.onload = async function () {
            log("System Loading (V1 - Advanced)...");

            // Default Values
            document.getElementById('genreCohesion').checked = true;
            document.getElementById('harmonicMixing').checked = true;

            if (typeof Papa === 'undefined') {
                log("ERROR: PapaParse missing!");
                alert("Critical Error: Libraries failed to load.");
            }

            // CHECK FOR SPOTIFY AUTH RETURN (PKCE Code Flow)
            const params = new URLSearchParams(window.location.search);
            const authCode = params.get('code');

            if (authCode) {
                log("Spotify Auth Code Received! Exchanging for Token...");

                // Exchange Code for Token
                const clientId = DEFAULT_CLIENT_ID;
                const redirectUri = window.location.href.split('?')[0]; // Current URL base
                const verifier = localStorage.getItem('spotify_code_verifier');

                const body = new URLSearchParams({
                    client_id: clientId,
                    grant_type: 'authorization_code',
                    code: authCode,
                    redirect_uri: redirectUri,
                    code_verifier: verifier
                });

                try {
                    const response = await fetch('https://accounts.spotify.com/api/token', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded'
                        },
                        body: body
                    });

                    if (!response.ok) {
                        const err = await response.json();
                        throw new Error(err.error_description || "Token exchange failed");
                    }

                    const data = await response.json();
                    const accessToken = data.access_token;
                    const expiresIn = data.expires_in;

                    log("Token Acquired!");
                    localStorage.setItem(ACCESS_TOKEN_KEY, accessToken);
                    localStorage.setItem('spotify_token_expiry', Date.now() + expiresIn * 1000);

                    // Clean URL
                    window.history.replaceState({}, document.title, window.location.pathname);

                    // Restore State
                    const savedState = localStorage.getItem(STATE_KEY);
                    if (savedState) {
                        const state = JSON.parse(savedState);
                        rawTracks = state.rawTracks || [];
                        phases = state.phases || [];

                        document.getElementById('startTime').value = state.startTime;
                        document.getElementById('endTime').value = state.endTime;
                        document.getElementById('flowMode').value = state.mode;
                        document.getElementById('import-status').textContent = `‚úÖ ${rawTracks.length} titres (Restored).`;
                        document.getElementById('step-config').classList.remove('hidden');
                        document.getElementById('step-results').classList.remove('hidden');

                        normalizeTracks(rawTracks);
                        calculateStats(rawTracks);
                        updateTimeCalculations();
                        draw();

                        log("State restored.");

                        // Auto-Resume Export if name was saved
                        if (state.pendingExportName) {
                            if (confirm(`Export pr√™t pour "${state.pendingExportName}". Continuer?`)) {
                                // We need to re-generate the playlistTracks since they weren't saved fully processed usually
                                // But we have rawTracks. The user needs to Click Generate usually to get the sorted list.
                                // A simpler way: Force user to click Generate again.
                                alert("Authentification r√©ussie ! Cliquez sur 'G√©n√©rer' puis sur 'Export to Spotify' pour finaliser.");
                            }
                        }
                    }

                } catch (e) {
                    log("PKCE Error: " + e.message);
                    console.error(e);
                    alert("Erreur d'authentification Spotify : " + e.message);
                }
                return;
            } else {
                // Check for Legacy Hash Error
                if (window.location.hash.includes('error=')) {
                    log("Auth Error detected in URL Hash.");
                    alert("Erreur d'authentification (Legacy). R√©essayez.");
                }
                updateTimeCalculations();
            }
        };

        // --- TIMING LOGIC ---
        const startTimeEl = document.getElementById('startTime');
        const endTimeEl = document.getElementById('endTime');
        const durationLabel = document.getElementById('totalDurationLabel');

        function updateTimeCalculations() {
            const start = startTimeEl.value; // "HH:MM"
            const end = endTimeEl.value;

            const [sh, sm] = start.split(':').map(Number);
            const [eh, em] = end.split(':').map(Number);

            let sMin = sh * 60 + sm;
            let eMin = eh * 60 + em;

            if (eMin < sMin) eMin += 24 * 60; // Overnight

            totalTimeMinutes = eMin - sMin;
            const h = Math.floor(totalTimeMinutes / 60);
            const m = totalTimeMinutes % 60;

            durationLabel.textContent = `${h}h ${m.toString().padStart(2, '0')}m`;
            if (phases.length > 0) draw(); // Redraw graph labels
        }

        startTimeEl.addEventListener('change', updateTimeCalculations);
        endTimeEl.addEventListener('change', updateTimeCalculations);

        // --- STEP 1: IMPORT ---
        document.getElementById('csvInput').addEventListener('change', function (evt) {
            const file = evt.target.files[0];
            if (!file) return;

            log(`File: ${file.name}`);
            document.getElementById('import-status').textContent = "Lecture...";

            Papa.parse(file, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function (results) {
                    try {
                        if (!results.data || results.data.length === 0) throw new Error("File empty");

                        rawTracks = results.data;
                        document.getElementById('import-status').textContent = `‚úÖ ${rawTracks.length} titres.`;

                        // Show Next Steps
                        document.getElementById('step-config').classList.remove('hidden');
                        document.getElementById('stats-section').classList.remove('hidden');

                        // Init App Logic
                        log("Initializing Visualization...");

                        // Normalization
                        normalizeTracks(rawTracks);

                        // Ensure graph loads
                        if (phases.length === 0) loadPreset();
                        else draw();

                        // Stats
                        calculateStats(rawTracks);

                    } catch (e) {
                        log("Error after parse: " + e.message);
                        console.error(e);
                        alert("Erreur: " + e.message);
                    }
                },
                error: function (err) {
                    log("CSV Parsing Error: " + err.message);
                }
            });
        });

        function normalizeTracks(tracks) {
            log("Normalizing data ranges...");

            // 1. Detect Scale for basic metrics (Energy, Dance, Valence)
            // Some exports use 0-1, others 0-100.
            let maxEnergy = 0;
            let minBPM = Infinity;
            let maxBPM = -Infinity;

            tracks.forEach(t => {
                if (t.Energy > maxEnergy) maxEnergy = t.Energy;

                const bpm = parseFloat(t.BPM || t.Tempo) || 0;
                if (bpm > 0) {
                    if (bpm < minBPM) minBPM = bpm;
                    if (bpm > maxBPM) maxBPM = bpm;
                }
            });

            const isScale100 = maxEnergy > 1.0;
            // Safety for BPM
            if (minBPM === Infinity) { minBPM = 60; maxBPM = 180; }
            if (minBPM === maxBPM) { minBPM = 0; maxBPM = 200; } // avoid div/0

            tracks.forEach(t => {
                // Normalize Metrics to 0-1
                const e = parseFloat(t.Energy) || 0;
                const d = parseFloat(t.Danceability) || 0;
                const v = parseFloat(t.Valence) || 0;

                t._nEnergy = isScale100 ? e / 100 : e;
                t._nDance = isScale100 ? d / 100 : d;
                t._nValence = isScale100 ? v / 100 : v;

                // Normalize BPM Relative to Playlist Range
                // 0 on graph = slowest song in playlist
                // 1 on graph = fastest song in playlist
                const bpm = parseFloat(t.BPM || t.Tempo) || minBPM;
                let normBPM = (bpm - minBPM) / (maxBPM - minBPM);
                normBPM = Math.max(0, Math.min(1, normBPM)); // Clamp

                t._nTempo = normBPM;
            });

            log(`Normalization Done. Scale=${isScale100 ? '0-100' : '0-1'}. BPM Range=${minBPM}-${maxBPM}`);
        }

        // --- STATS LOGIC ---
        let genreChartInst = null;
        let criteriaChartInst = null;
        let resultChartInst = null; // New Chart Instance

        // Helper for genre aggregation (Ensure this is available)
        function getAggregatedGenre(genreString) {
            if (!genreString) return "Unknown";
            const g = genreString.toLowerCase();

            if (g.match(/hip hop|rap|trap|drill|grime/)) return "Hip Hop / Rap";
            if (g.match(/house|techno|trance|edm|dance|electro|disco|club/)) return "Electronic / Dance";
            if (g.match(/pop|charts|top/)) return "Pop";
            if (g.match(/rock|metal|punk|indie|grunge/)) return "Rock / Indie";
            if (g.match(/r&b|soul|funk|motown|neo/)) return "R&B / Soul";
            if (g.match(/jazz|blues|swing/)) return "Jazz / Blues";
            if (g.match(/latin|reggaeton|salsa|bachata/)) return "Latin";
            if (g.match(/reggae|dancehall|dub/)) return "Reggae";
            if (g.match(/classical|orchestra|piano/)) return "Classical";
            if (g.match(/country|folk|acoustic/)) return "Folk / Country";

            return "Autre";
        }

        function calculateStats(tracks) {
            if (typeof Chart === 'undefined') {
                log("Chart.js missing - Skipping Stats Charts");
                document.getElementById('stats-section').innerHTML += "<p style='color:red'>Erreur: Chart.js introuvable.</p>";
                return;
            }

            try {
                // 1. Genre Distribution (Pie)
                const genreCounts = {};
                tracks.forEach(t => {
                    let gRaw = "Unknown";
                    // Robust check for different CSV formats
                    if (t['Genres']) gRaw = t['Genres'];
                    else if (t['Artist Genres']) gRaw = t['Artist Genres'];
                    else if (t['Genre']) gRaw = t['Genre'];

                    // Use Aggregation
                    const g = getAggregatedGenre(gRaw);
                    genreCounts[g] = (genreCounts[g] || 0) + 1;
                });

                const sortedGenres = Object.entries(genreCounts)
                    .sort((a, b) => b[1] - a[1]);

                const ctxG = document.getElementById('genreChart');
                if (ctxG) {
                    if (genreChartInst) genreChartInst.destroy();
                    genreChartInst = new Chart(ctxG.getContext('2d'), {
                        type: 'pie',
                        data: {
                            labels: sortedGenres.map(x => x[0]),
                            datasets: [{
                                data: sortedGenres.map(x => x[1]),
                                backgroundColor: [
                                    '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF',
                                    '#FF9F40', '#E7E9ED', '#76A346', '#800080', '#000080'
                                ]
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                title: { display: true, text: 'Genres (Aggregated)' },
                                legend: { position: 'right' }
                            }
                        }
                    });
                }

                // 2. Criteria Distribution (Bar)
                const buckets = {
                    energy: [0, 0, 0, 0, 0],
                    dance: [0, 0, 0, 0, 0],
                    valence: [0, 0, 0, 0, 0]
                };

                tracks.forEach(t => {
                    const bucketIdx = (val) => Math.min(4, Math.floor((parseFloat(val) || 0) * 5));
                    if (t.Energy !== undefined) buckets.energy[bucketIdx(t.Energy)]++;
                    if (t.Danceability !== undefined) buckets.dance[bucketIdx(t.Danceability)]++;
                    if (t.Valence !== undefined) buckets.valence[bucketIdx(t.Valence)]++;
                });

                const ctxC = document.getElementById('criteriaChart');
                if (ctxC) {
                    if (criteriaChartInst) criteriaChartInst.destroy();
                    criteriaChartInst = new Chart(ctxC.getContext('2d'), {
                        type: 'bar',
                        data: {
                            labels: ['0-20%', '20-40%', '40-60%', '60-80%', '80-100%'],
                            datasets: [
                                { label: 'Energy', data: buckets.energy, backgroundColor: 'rgba(255, 99, 132, 0.7)' },
                                { label: 'Dance', data: buckets.dance, backgroundColor: 'rgba(54, 162, 235, 0.7)' },
                                { label: 'Valence', data: buckets.valence, backgroundColor: 'rgba(75, 192, 192, 0.7)' }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                title: { display: true, text: 'Crit√®res Distribution' }
                            }
                        }
                    });
                }
            } catch (e) {
                log("Stats Error: " + e.message);
                console.error(e);
            }
        }

        // --- STEP 2: ADVANCED GRAPH ---
        const canvas = document.getElementById('flowChart');
        const ctx = canvas.getContext('2d');
        let isDragging = false;
        let dragTarget = null; // { type: 'point'|'separator', index: 0, prop: 'energy' }

        // Presets - values based on DJ industry standards & Spotify Audio Analysis
        const PRESETS = {
            custom: () => [],
            party: (n) => [
                // Warm-up: Mod-Low Energy, Building Tempo
                { name: "Warm-up", d: 0.15, e: 0.45, da: 0.55, v: 0.60, t: 0.30 },
                // Build-up: Increasing Intensity
                { name: "Build-up", d: 0.20, e: 0.65, da: 0.70, v: 0.70, t: 0.50 },
                // Peak Time: High Energy, Max Danceability, High Happiness
                { name: "Peak 1", d: 0.20, e: 0.90, da: 0.90, v: 0.85, t: 0.80 },
                { name: "Peak 2", d: 0.25, e: 0.85, da: 0.88, v: 0.90, t: 0.75 },
                // Cool Down: Drop in Tempo & Energy
                { name: "Cool Down", d: 0.20, e: 0.40, da: 0.50, v: 0.50, t: 0.25 }
            ],
            apero: (n) => [
                // Lounge/Chill: Consistent Mellow Vibe (Low Energy, High Valence)
                { name: "Welcome", d: 0.2, e: 0.35, da: 0.45, v: 0.75, t: 0.20 },
                { name: "Chill", d: 0.2, e: 0.40, da: 0.50, v: 0.80, t: 0.25 },
                { name: "Conversation", d: 0.2, e: 0.40, da: 0.55, v: 0.85, t: 0.30 },
                { name: "Groove", d: 0.2, e: 0.50, da: 0.60, v: 0.90, t: 0.35 },
                { name: "Sunset", d: 0.2, e: 0.30, da: 0.40, v: 0.70, t: 0.20 }
            ],
            sport: (n) => [
                // HIIT/Cardio Structure
                // Warm-up: 100-120 BPM
                { name: "Warm-up", d: 0.15, e: 0.55, da: 0.60, v: 0.60, t: 0.40 },
                // High Intensity: >0.8 Energy, Fast Tempo (140+)
                { name: "High Intensity 1", d: 0.30, e: 0.95, da: 0.80, v: 0.75, t: 0.90 },
                { name: "High Intensity 2", d: 0.30, e: 0.90, da: 0.85, v: 0.80, t: 0.95 },
                // Recovery/Cool Down: Slow
                { name: "Cool Down", d: 0.25, e: 0.40, da: 0.40, v: 0.50, t: 0.20 }
            ]
        };

        // --- GRAPH STATE MANAGEMENT ---

        function loadPreset() {
            const numPhases = parseInt(document.getElementById('numPhases').value) || 5;
            const mode = document.getElementById('flowMode').value;

            // Set Default Times based on Mode
            const startEl = document.getElementById('startTime');
            const endEl = document.getElementById('endTime');

            if (mode === 'party') {
                startEl.value = "21:00";
                endEl.value = "03:00"; // 6h duration
            } else if (mode === 'apero') {
                startEl.value = "18:00";
                endEl.value = "21:00"; // 3h duration
            } else if (mode === 'sport') {
                startEl.value = "18:00";
                endEl.value = "19:00"; // 1h duration standard for workout
            }
            // Trigger time update to recalculate total minutes
            updateTimeCalculations();

            // Default Checkboxes to True (User Preference)
            document.getElementById('genreCohesion').checked = true;
            document.getElementById('harmonicMixing').checked = true;

            // If custom, do nothing or just init empty
            if (mode === 'custom') {
                resizeGraph();
                return;
            }

            const presetFunc = PRESETS[mode] || PRESETS.party;
            const presetData = presetFunc(numPhases);

            // Map preset to phases
            if (presetData.length === numPhases) {
                // Exact match
                phases = presetData.map(p => ({
                    name: p.name, durationPercent: p.d, energy: p.e, dance: p.da, valence: p.v || 0.5, tempo: p.t || 0.5
                }));
            } else {
                // Mismatch length? Initial interpolation from preset source
                interpolateFromSource(presetData.map(p => ({
                    name: p.name, durationPercent: p.d, energy: p.e, dance: p.da, valence: p.v || 0.5, tempo: p.t || 0.5
                })), numPhases);
            }

            normalizeDurations();
            draw();
        }

        function resizeGraph() {
            const numPhases = parseInt(document.getElementById('numPhases').value) || 5;

            if (phases.length === 0) {
                // Cold start
                loadPreset();
                return;
            }

            if (phases.length === numPhases) return; // No change

            // Extrapolate/Interpolate from CURRENT phases
            interpolateFromSource(phases, numPhases);

            normalizeDurations();
            draw();
        }

        function interpolateFromSource(source, targetCount) {
            const newPhases = [];
            for (let i = 0; i < targetCount; i++) {
                const progress = i / (targetCount - 1);

                // Map to source index
                const sourcePos = progress * (source.length - 1);
                const idxA = Math.floor(sourcePos);
                const idxB = Math.min(source.length - 1, Math.ceil(sourcePos));
                const t = sourcePos - idxA;

                const pA = source[idxA];
                const pB = source[idxB];

                // Standard DJ Naming Logic based on Position
                let newName = "Phase";
                if (i === 0) newName = "Warm-up";
                else if (i === targetCount - 1) newName = "Cool Down";
                else {
                    // Mid sections
                    if (progress < 0.35) newName = "Build-up";
                    else if (progress < 0.70) newName = "Peak";
                    else newName = "Sustain";
                }

                newPhases.push({
                    name: newName, // Will be numbered later if duplicate
                    durationPercent: 1 / targetCount,
                    energy: lerp(pA.energy, pB.energy, t),
                    dance: lerp(pA.dance, pB.dance, t),
                    valence: lerp(pA.valence || 0.5, pB.valence || 0.5, t),
                    tempo: lerp(pA.tempo || 0.5, pB.tempo || 0.5, t)
                });
            }

            // Smart Numbering for duplicates (e.g. Peak 1, Peak 2)
            const counts = {};
            newPhases.forEach(p => counts[p.name] = (counts[p.name] || 0) + 1);

            const current = {};
            newPhases.forEach(p => {
                if (counts[p.name] > 1) {
                    current[p.name] = (current[p.name] || 0) + 1;
                    p.name = `${p.name} ${current[p.name]}`;
                }
            });

            phases = newPhases;
        }

        function lerp(a, b, t) { return a + (b - a) * t; }
        function normalizeDurations() {
            const total = phases.reduce((acc, p) => acc + p.durationPercent, 0);
            phases.forEach(p => p.durationPercent /= total);
        }

        // Binds
        document.getElementById('resetGraphBtn').onclick = loadPreset;
        document.getElementById('flowMode').onchange = loadPreset;
        document.getElementById('numPhases').onchange = resizeGraph;

        // Initial Call
        setTimeout(loadPreset, 100);

        // --- DRAWING ---

        function draw() {
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const w = canvas.width;
            const h = canvas.height;
            const padding = 40;
            const leftPadding = 35; // Space for Y axis

            // Background Grid & Y-Axis Labels
            ctx.strokeStyle = '#f0f0f0';
            ctx.fillStyle = '#999';
            ctx.textAlign = 'right';
            ctx.font = '10px monospace';

            ctx.beginPath();
            for (let i = 0; i <= 4; i++) {
                // 0% at Bottom, 100% at Top
                const val = 100 - (i * 25);
                const y = i * (h - padding) / 4;

                ctx.moveTo(leftPadding, y);
                ctx.lineTo(w, y);

                // Label
                ctx.fillText(val + "%", leftPadding - 5, y + 3);
            }
            ctx.stroke();

            // Calculate Start X for each phase
            let currentXPct = 0;
            const phaseMeta = [];

            phases.forEach((p, i) => {
                const startX = leftPadding + (currentXPct * (w - leftPadding)); // Offset by leftPadding
                const phasesWidthTotal = w - leftPadding;
                const phaseW = p.durationPercent * phasesWidthTotal;
                const centerX = startX + (phaseW / 2);

                phaseMeta.push({
                    i: i,
                    startX: startX,
                    endX: startX + phaseW,
                    centerX: centerX,
                    centerY_E: (1 - p.energy) * (h - padding),
                    centerY_D: (1 - p.dance) * (h - padding),
                    centerY_V: (1 - p.valence) * (h - padding),
                    centerY_T: (1 - p.tempo) * (h - padding),
                    val_E: p.energy,
                    val_D: p.dance,
                    val_V: p.valence,
                    val_T: p.tempo,
                    name: p.name
                });

                // Draw Separator
                if (i < phases.length - 1) {
                    ctx.beginPath();
                    ctx.strokeStyle = '#ccc';
                    ctx.setLineDash([5, 5]);
                    ctx.moveTo(startX + phaseW, 0);
                    ctx.lineTo(startX + phaseW, h - padding);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Handle
                    ctx.fillStyle = '#ddd';
                    ctx.fillRect(startX + phaseW - 3, h / 2 - 10, 6, 20);
                }

                currentXPct += p.durationPercent;
            });

            canvas.phaseMeta = phaseMeta;

            // Draw Lines & Points
            drawCurve(phaseMeta, 'energy', 'centerY_E', 'val_E', 'rgba(255, 99, 132, 1)');
            drawCurve(phaseMeta, 'dance', 'centerY_D', 'val_D', 'rgba(54, 162, 235, 1)');
            drawCurve(phaseMeta, 'valence', 'centerY_V', 'val_V', 'rgba(75, 192, 192, 1)');
            drawCurve(phaseMeta, 'tempo', 'centerY_T', 'val_T', 'rgba(255, 206, 86, 1)');

            // X-Axis Labels
            ctx.textAlign = 'center';
            ctx.fillStyle = '#999';

            // Start/End
            ctx.fillText(document.getElementById('startTime').value, leftPadding + 20, h - 5);
            ctx.fillText(document.getElementById('endTime').value, w - 25, h - 5);

            // Phase Names & Middle Times
            let timeAccum = 0;
            const [sh, sm] = document.getElementById('startTime').value.split(':').map(Number);
            const refStartMin = sh * 60 + sm;

            phases.forEach((p, i) => {
                const meta = phaseMeta[i];

                // Name
                ctx.font = 'bold 11px sans-serif';
                ctx.fillStyle = '#333';
                ctx.fillText(p.name || `P${i + 1}`, meta.centerX, h - 20);

                timeAccum += p.durationPercent * totalTimeMinutes;

                // Separator Time
                if (i < phases.length - 1) {
                    const minVal = Math.floor(refStartMin + timeAccum);
                    const labelH = Math.floor((minVal / 60) % 24);
                    const labelM = Math.floor(minVal % 60);
                    const label = `${labelH}:${labelM.toString().padStart(2, '0')}`;

                    ctx.font = '10px monospace';
                    ctx.fillStyle = '#666';
                    ctx.fillText(label, meta.endX, h - 5);
                }
            });
        }

        function drawCurve(meta, prop, yProp, valProp, color) {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;

            // Prepare points
            const points = meta.map(m => ({ x: m.centerX, y: m[yProp] }));

            if (points.length > 0) {
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 0; i < points.length - 1; i++) {
                    const curr = points[i];
                    const next = points[i + 1];
                    const cp1x = curr.x + (next.x - curr.x) / 2;
                    const cp1y = curr.y;
                    const cp2x = curr.x + (next.x - curr.x) / 2;
                    const cp2y = next.y;
                    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, next.x, next.y);
                }
            }
            ctx.stroke();

            // Points & Data Labels
            meta.forEach(m => {
                const x = m.centerX;
                const y = m[yProp];
                const val = m[valProp] !== undefined ? m[valProp] : 0.5; // Safety default

                // Draw Point
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, Math.PI * 2); // Slightly larger
                ctx.fillStyle = 'white';
                ctx.fill();
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw Label Box
                // Position above the point
                const labelTxt = (val * 100).toFixed(0) + "%";
                const txtWidth = ctx.measureText(labelTxt).width;
                const boxW = txtWidth + 10;
                const boxH = 16;
                const boxX = x - boxW / 2;
                const boxY = y - 28;

                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; // High contrast background
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1;
                ctx.fillRect(boxX, boxY, boxW, boxH);
                ctx.strokeRect(boxX, boxY, boxW, boxH);

                // Draw Label Text
                ctx.fillStyle = '#333'; // Dark text
                ctx.font = 'bold 11px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(labelTxt, x, boxY + 12);
            });
        }

        // --- INTERACTION ---
        canvas.addEventListener('mousedown', e => {
            const r = canvas.getBoundingClientRect();
            const scaleX = canvas.width / r.width;
            const scaleY = canvas.height / r.height;
            const mx = (e.clientX - r.left) * scaleX;
            const my = (e.clientY - r.top) * scaleY;

            const meta = canvas.phaseMeta;
            if (!meta) return;

            // 1. Check Separators
            for (let i = 0; i < meta.length - 1; i++) {
                if (Math.abs(mx - meta[i].endX) < 15) {
                    isDragging = true;
                    dragTarget = { type: 'separator', index: i };
                    return;
                }
            }

            // 2. Check Points
            for (let i = 0; i < meta.length; i++) {
                if (Math.hypot(mx - meta[i].centerX, my - meta[i].centerY_E) < 15) {
                    isDragging = true; dragTarget = { type: 'point', index: i, prop: 'energy' }; return;
                }
                if (Math.hypot(mx - meta[i].centerX, my - meta[i].centerY_D) < 15) {
                    isDragging = true; dragTarget = { type: 'point', index: i, prop: 'dance' }; return;
                }
                if (Math.hypot(mx - meta[i].centerX, my - meta[i].centerY_V) < 15) {
                    isDragging = true; dragTarget = { type: 'point', index: i, prop: 'valence' }; return;
                }
                if (Math.hypot(mx - meta[i].centerX, my - meta[i].centerY_T) < 15) {
                    isDragging = true; dragTarget = { type: 'point', index: i, prop: 'tempo' }; return;
                }
            }
        });

        canvas.addEventListener('mousemove', e => {
            const r = canvas.getBoundingClientRect();
            const scaleX = canvas.width / r.width;
            const scaleY = canvas.height / r.height;
            const mx = (e.clientX - r.left) * scaleX;
            const my = (e.clientY - r.top) * scaleY;

            let cursor = 'default';
            if (canvas.phaseMeta) {
                for (let i = 0; i < canvas.phaseMeta.length - 1; i++) {
                    if (Math.abs(mx - canvas.phaseMeta[i].endX) < 15) cursor = 'col-resize';
                }
            }
            canvas.style.cursor = cursor;

            if (!isDragging || !dragTarget) return;

            if (dragTarget.type === 'point') {
                const h = canvas.height - 40; // padding adjusted
                let val = 1 - (my / h);
                val = Math.max(0, Math.min(1, val));
                phases[dragTarget.index][dragTarget.prop] = val;
            }
            else if (dragTarget.type === 'separator') {
                // Dragging separator i implies adjusting width of i and i+1
                const i = dragTarget.index;
                const meta = canvas.phaseMeta;

                // Calculate new split based on pixels
                const startX = meta[i].startX;
                const endX = meta[i + 1].endX; // Total width shared by both

                // New width of left phase (i)
                let newWPx = mx - startX;
                const totalWPx = endX - startX;

                // Constraints (min 20px)
                if (newWPx < 20) newWPx = 20;
                if (newWPx > totalWPx - 20) newWPx = totalWPx - 20;

                const newRatio = newWPx / totalWPx;

                // Their combined duration percent
                const combinedPct = phases[i].durationPercent + phases[i + 1].durationPercent;

                phases[i].durationPercent = combinedPct * newRatio;
                phases[i + 1].durationPercent = combinedPct * (1 - newRatio);
            }

            draw();
        });

        canvas.addEventListener('mouseup', () => { isDragging = false; dragTarget = null; });

        // --- RESIZE HANDLER ---
        window.addEventListener('resize', () => {
            if (phases.length > 0) initGraph();
        });


        // Helper to get Camelot Key
        // Returns object { num: 8, letter: 'A' } or null
        function getCamelot(track) {
            // If already has Camelot string
            if (track.Camelot) {
                const match = track.Camelot.match(/(\d+)([AB])/);
                if (match) return { num: parseInt(match[1]), letter: match[2] };
            }

            // Calculate from Key/Mode
            const key = parseInt(track.Key);
            const mode = parseInt(track.Mode);

            if (isNaN(key) || isNaN(mode)) return null;

            // Camelot Logic
            // Major (Mode 1): 0=8B, 1=3B, 2=10B, 3=5B, 4=12B, 5=7B, 6=2B, 7=9B, 8=4B, 9=11B, 10=6B, 11=1B
            // Minor (Mode 0): 0=5A, 1=12A, 2=7A, 3=2A, 4=9A, 5=4A, 6=11A, 7=6A, 8=1A, 9=8A, 10=3A, 11=10A

            const majorMap = [8, 3, 10, 5, 12, 7, 2, 9, 4, 11, 6, 1];
            const minorMap = [5, 12, 7, 2, 9, 4, 11, 6, 1, 8, 3, 10];

            const num = mode === 1 ? majorMap[key] : minorMap[key];
            const letter = mode === 1 ? 'B' : 'A';

            return { num, letter };
        }

        function normalizeTracks(tracks) {
            log("Normalizing data ranges...");

            // 1. Detect Scale for basic metrics
            let maxEnergy = 0;
            let minBPM = Infinity;
            let maxBPM = -Infinity;

            tracks.forEach(t => {
                const e = parseFloat(t.Energy) || 0;
                if (e > maxEnergy) maxEnergy = e;

                const bpm = parseFloat(t.BPM || t.Tempo) || 0;
                if (bpm > 0) {
                    if (bpm < minBPM) minBPM = bpm;
                    if (bpm > maxBPM) maxBPM = bpm;
                }
            });

            const isScale100 = maxEnergy > 1.0;
            if (minBPM === Infinity) { minBPM = 60; maxBPM = 180; }
            if (minBPM === maxBPM) { minBPM = 0; maxBPM = 200; }

            tracks.forEach(t => {
                // Normalize Metrics
                const e = parseFloat(t.Energy) || 0;
                const d = parseFloat(t.Danceability) || 0;
                const v = parseFloat(t.Valence) || 0;

                t._nEnergy = isScale100 ? e / 100 : e;
                t._nDance = isScale100 ? d / 100 : d;
                t._nValence = isScale100 ? v / 100 : v;

                // Normalize BPM
                const bpm = parseFloat(t.BPM || t.Tempo) || minBPM;
                const normBPM = Math.max(0, Math.min(1, (bpm - minBPM) / (maxBPM - minBPM)));
                t._nTempo = normBPM;

                // Pre-calc Camelot
                t._camelot = getCamelot(t);
            });

            log(`Normalization Done. Scale=${isScale100 ? '0-100' : '0-1'}. BPM Range=${minBPM}-${maxBPM}`);
        }

        // --- STEP 3: GENERATION (Duration Based & Genre Chaining) ---
        document.getElementById('generateBtn').addEventListener('click', function () {
            log("Computing Playlist...");

            let pool = [...rawTracks];
            let playlist = [];
            let currentDurMs = 0;
            const totalDurMs = totalTimeMinutes * 60000;

            // Constraints
            const useGenreCohesion = document.getElementById('genreCohesion').checked;
            const useHarmonic = document.getElementById('harmonicMixing').checked;

            let currentGenre = null;
            let genreStreak = 0;
            let currentCamelot = null;

            phases.forEach((p, i) => {
                const phaseTargetDur = totalDurMs * p.durationPercent;
                let phaseCurrentDur = 0; // Accumulator for this phase

                log(`Allocating ${p.name}: Target ${(phaseTargetDur / 60000).toFixed(1)}m`);

                while (phaseCurrentDur < phaseTargetDur && pool.length > 0) {
                    let bestIdx = -1;
                    let bestScore = Infinity;

                    for (let k = 0; k < pool.length; k++) {
                        const t = pool[k];

                        // Normalized Values
                        const tE = t._nEnergy !== undefined ? t._nEnergy : 0.5;
                        const tD = t._nDance !== undefined ? t._nDance : 0.5;
                        const tV = t._nValence !== undefined ? t._nValence : 0.5;
                        const tT = t._nTempo !== undefined ? t._nTempo : 0.5;

                        // Euclidean Distance (Core)
                        let dist = Math.sqrt(
                            (tE - p.energy) ** 2 +
                            (tD - p.dance) ** 2 +
                            (tV - p.valence) ** 2 +
                            (tT - p.tempo) ** 2
                        );

                        // --- GENRE CONSTRAINT ---
                        if (useGenreCohesion && playlist.length > 0 && currentGenre) {
                            let tGenre = getAggregatedGenre(t['Genres'] || t['Artist Genres'] || t['Genre']);
                            if (tGenre === currentGenre) {
                                if (genreStreak >= 3) dist += 10.0; // Penalty (Force Switch)
                                else dist -= 0.1; // Bonus (Keep Going)
                            } else {
                                if (genreStreak < 2) dist += 2.0; // Penalty (Switch too soon)
                            }
                        }

                        // --- HARMONIC CONSTRAINT ---
                        if (useHarmonic && playlist.length > 0 && currentCamelot && t._camelot) {
                            // Check compatibility
                            // Perfect: Same (8A -> 8A)
                            // Compatible: +/- 1 Number (8A -> 7A, 9A)
                            // Mode Swap: Same number, diff letter (8A -> 8B)

                            const c1 = currentCamelot;
                            const c2 = t._camelot;

                            let isCompatible = false;

                            if (c1.num === c2.num && c1.letter === c2.letter) isCompatible = true; // Exact
                            else if (c1.num === c2.num && c1.letter !== c2.letter) isCompatible = true; // Mode swap
                            else if (c1.letter === c2.letter) {
                                // Number adjacency (handling 12-1 wrap)
                                const diff = Math.abs(c1.num - c2.num);
                                if (diff === 1 || diff === 11) isCompatible = true;
                            }

                            if (!isCompatible) {
                                dist += 0.5; // Penalty for disharmonic
                            } else {
                                dist -= 0.2; // Bonus for harmonic
                            }
                        }

                        if (dist < bestScore) {
                            bestScore = dist;
                            bestIdx = k;
                        }
                    }

                    if (bestIdx !== -1) {
                        const track = pool[bestIdx];
                        const tDur = parseInt(track['Duration (ms)']) || 200000;

                        // Update Streak Logic
                        if (useGenreCohesion) {
                            let gRaw = track['Genres'] || track['Artist Genres'] || track['Genre'] || "";
                            let tGenre = getAggregatedGenre(gRaw);

                            if (tGenre === currentGenre) {
                                genreStreak++;
                            } else {
                                currentGenre = tGenre;
                                genreStreak = 1;
                            }
                        }

                        if (track._camelot) currentCamelot = track._camelot;

                        playlist.push(track);
                        pool.splice(bestIdx, 1);

                        phaseCurrentDur += tDur;
                        currentDurMs += tDur;
                    } else {
                        break;
                    }
                }
            });

            log(`Generation done. Total: ${(currentDurMs / 60000).toFixed(1)}m`);
            renderTable(playlist);
            document.getElementById('step-results').classList.remove('hidden');
            document.getElementById('step-results').scrollIntoView({ behavior: 'smooth' });
        });

        function renderTable(tracks) {
            // Update Headers
            const thead = document.querySelector('#resultTable thead tr');
            thead.innerHTML = `
                <th>#</th>
                <th>Heure</th>
                <th>Titre</th>
                <th>Artiste</th>
                <th>Dur√©e</th>
                <th>Genre</th>
                <th>BPM</th>
                <th>Energy</th>
                <th>Dance</th>
                <th>Valence</th>
            `;

            const tbody = document.querySelector('#resultTable tbody');
            tbody.innerHTML = '';

            // Calculate Start Time
            let currentTime = 0; // ms offset
            const startVal = document.getElementById('startTime').value;
            const [sh, sm] = startVal.split(':').map(Number);
            const startMs = (sh * 3600 + sm * 60) * 1000;

            tracks.forEach((t, i) => {
                // Calculate actual time for this track
                const trackStartMs = startMs + currentTime;
                const date = new Date(trackStartMs);
                const timeStr = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

                // Duration
                const durMs = parseInt(t['Duration (ms)'] || 0);
                const durMin = Math.floor(durMs / 60000);
                const durSec = Math.floor((durMs % 60000) / 1000);
                const durStr = `${durMin}:${durSec.toString().padStart(2, '0')}`;

                // Genre
                let gRaw = t['Genres'] || t['Artist Genres'] || t['Genre'] || "";
                let genreDisplay = getAggregatedGenre(gRaw);

                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${i + 1}</td>
                    <td>${timeStr}</td>
                    <td>${t['Track Name'] || '???'}</td>
                    <td>${t['Artist Name(s)'] || ''}</td>
                    <td>${durStr}</td>
                    <td>${genreDisplay}</td>
                    <td>${t.BPM || t.Tempo || ''}</td>
                    <td>${parseFloat(t.Energy).toFixed(2)}</td>
                    <td>${parseFloat(t.Danceability).toFixed(2)}</td>
                    <td>${parseFloat(t.Valence).toFixed(2)}</td>
                `;
                tbody.appendChild(tr);

                currentTime += durMs;
            });

            // Buttons Logic
            // Show Download Button
            const downBtn = document.getElementById('downloadBtn');
            downBtn.onclick = function () {
                const csv = Papa.unparse(tracks);
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'playlist_final.csv';
                a.click();
            };

            // Show Spotify Button
            const spotifyBtn = document.getElementById('spotifyExportBtn');
            spotifyBtn.classList.remove('hidden');
            spotifyBtn.onclick = function () {
                handleSpotifyExport(tracks);
            };

            // Render the Result Chart
            renderResultChart(tracks);
        }

        function renderResultChart(tracks) {
            const ctx = document.getElementById('resultChart').getContext('2d');

            // Prepare Data
            const labels = tracks.map((_, i) => {
                // Return Time label if possible, else Index
                // We can approximate time based on cumulative duration
                return i + 1;
            });

            // Extract Metrics (handle raw string or normalized?)
            // The user snippet uses 0-1 range. Our csv might have 0-1 or 0-100.
            // normalizeTracks() ensures _nEnergy, _nDance, _nValence are 0-1.
            const energy = tracks.map(t => t._nEnergy);
            const dance = tracks.map(t => t._nDance);
            const valence = tracks.map(t => t._nValence);

            // BPM (Display raw BPM)
            const bpm = tracks.map(t => parseFloat(t.BPM || t.Tempo) || 0);

            if (resultChartInst) {
                resultChartInst.destroy();
            }

            resultChartInst = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels, // Track Numbers
                    datasets: [
                        // --- Left Axis Metrics (0-1) ---
                        {
                            label: 'Energy (Puissance)',
                            data: energy,
                            borderColor: '#d62728', // Red
                            backgroundColor: '#d62728',
                            yAxisID: 'yMetrics',
                            tension: 0.3,
                            borderWidth: 2,
                            pointRadius: 2,
                            pointHoverRadius: 4
                        },
                        {
                            label: 'Danceability (Groove)',
                            data: dance,
                            borderColor: '#2ca02c', // Green
                            backgroundColor: '#2ca02c',
                            yAxisID: 'yMetrics',
                            borderDash: [5, 5], // Dashed line
                            tension: 0.3,
                            borderWidth: 2,
                            pointRadius: 2,
                            pointHoverRadius: 4
                        },
                        {
                            label: 'Valence (√âmotion)',
                            data: valence,
                            borderColor: '#1f77b4', // Blue
                            backgroundColor: '#1f77b4',
                            yAxisID: 'yMetrics',
                            tension: 0.3,
                            borderWidth: 2,
                            pointRadius: 2,
                            pointHoverRadius: 4
                        },
                        // --- Right Axis Metric (BPM) ---
                        {
                            label: 'Tempo (BPM)',
                            data: bpm,
                            borderColor: 'purple',
                            backgroundColor: 'rgba(128, 0, 128, 0.1)',
                            yAxisID: 'yBPM',
                            tension: 0.2,
                            borderWidth: 3,
                            pointStyle: 'rectRot', // Distinct shape for BPM
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            fill: true
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    scales: {
                        x: {
                            grid: {
                                display: false
                            },
                            ticks: {
                                maxTicksLimit: 20 // Avoid crowding
                            },
                            title: {
                                display: true,
                                text: 'S√©quence des Titres'
                            }
                        },
                        // Left Axis: 0.0 - 1.0
                        yMetrics: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            min: 0,
                            max: 1.0,
                            title: {
                                display: true,
                                text: 'Intensit√© (0.0 - 1.0)',
                                color: '#666',
                                font: { weight: 'bold' }
                            }
                        },
                        // Right Axis: BPM
                        yBPM: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            // Let it auto-scale nicely
                            grid: {
                                drawOnChartArea: false
                            },
                            title: {
                                display: true,
                                text: 'Tempo (BPM)',
                                color: 'purple',
                                font: { weight: 'bold' }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                padding: 20
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            titleColor: '#000',
                            bodyColor: '#333',
                            borderColor: '#ddd',
                            borderWidth: 1,
                            callbacks: {
                                title: function (context) {
                                    // Show Track Name in Tooltip if possible
                                    const idx = context[0].dataIndex;
                                    const t = tracks[idx];
                                    return `${idx + 1}. ${t['Track Name'] || 'Track'}`;
                                }
                            }
                        }
                    }
                }
            });
        }

    </script>
</body>

</html>