<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <title>Triateur de Playlists (V0 - Clean Rewrite)</title>
    <!-- External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>

    <style>
        :root {
            --spotify-green: #1DB954;
            --spotify-black: #191414;
            --light-grey: #f5f5f5;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--light-grey);
            color: #333;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            background: white;
            max-width: 900px;
            width: 100%;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: var(--spotify-green);
            text-align: center;
            margin-bottom: 10px;
        }

        .version {
            font-size: 0.6em;
            color: #666;
            vertical-align: middle;
        }

        /* Steps */
        .step {
            margin-bottom: 30px;
            padding: 20px;
            border-left: 4px solid var(--spotify-green);
            background: #fafafa;
            border-radius: 0 8px 8px 0;
        }

        .hidden {
            display: none;
        }

        /* Buttons */
        .btn {
            background-color: var(--spotify-green);
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 30px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.2s;
            text-decoration: none;
            display: inline-block;
        }

        .btn:hover {
            background-color: #1ed760;
            transform: scale(1.02);
        }

        .btn-secondary {
            background-color: #555;
        }

        /* Inputs */
        input[type="file"] {
            border: 2px dashed #ccc;
            padding: 20px;
            width: 100%;
            box-sizing: border-box;
            text-align: center;
            cursor: pointer;
        }

        /* Graph Container */
        .graph-container {
            position: relative;
            height: 400px;
            width: 100%;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: white;
            margin-top: 20px;
        }

        /* Table */
        .table-responsive {
            overflow-x: auto;
            margin-top: 20px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
        }

        th,
        td {
            padding: 10px;
            border-bottom: 1px solid #eee;
            text-align: left;
        }

        th {
            background-color: #f8f8f8;
        }

        /* Debug Box */
        #debug-log {
            font-family: monospace;
            font-size: 12px;
            background: #333;
            color: #0f0;
            padding: 10px;
            border-radius: 4px;
            margin-top: 20px;
            max-height: 150px;
            overflow-y: auto;
            display: none;
            /* Hidden by default */
        }
    </style>
</head>

<body>

    <div class="container">
        <h1>Triateur de Playlists ü™© <span class="version">(V0 - Clean Core)</span></h1>

        <div style="text-align: center; margin-bottom: 20px;">
            <button onclick="window.location.reload()" class="btn btn-secondary"
                style="font-size: 0.8em; padding: 5px 15px;">
                ‚Üª Recharger l'app
            </button>
        </div>

        <!-- DEBUG LOG -->
        <div id="debug-log">Log system initiated...</div>

        <!-- STEP 1: IMPORT -->
        <div id="step-import" class="step">
            <h2>1. Import (CSV)</h2>
            <p>Exportez votre playlist depuis <a href="https://exportify.net" target="_blank">Exportify.net</a> (Format
                CSV) et glissez-la ici.</p>
            <input type="file" id="csvInput" accept=".csv" />
            <p id="import-status" style="margin-top: 10px; font-weight: bold;"></p>
        </div>

        <!-- STEP 2: CONFIG & GRAPH -->
        <div id="step-config" class="step hidden">
            <h2>2. Design Your Flow üåä</h2>
            <div style="display: flex; gap: 20px; margin-bottom: 15px; flex-wrap: wrap;">
                <div>
                    <label>Phases:</label>
                    <input type="number" id="numPhases" value="5" min="3" max="10" style="padding: 5px;">
                </div>
                <div>
                    <button id="resetGraphBtn" class="btn btn-secondary"
                        style="padding: 6px 12px; font-size: 14px;">R√©initialiser Graph</button>
                </div>
            </div>

            <p class="small">Glissez les points pour ajuster :
                <span style="color:rgba(255, 99, 132, 1)">‚óè Energy</span>,
                <span style="color:rgba(54, 162, 235, 1)">‚óè Danceability</span>
            </p>

            <div class="graph-container">
                <canvas id="flowChart"></canvas>
            </div>

            <div style="text-align: center; margin-top: 30px;">
                <button id="generateBtn" class="btn">üöÄ G√©n√©rer la Playlist</button>
            </div>
        </div>

        <!-- STEP 3: RESULTS -->
        <div id="step-results" class="step hidden">
            <h2>3. R√©sultats</h2>
            <p id="result-summary"></p>
            <button id="downloadBtn" class="btn">üì• T√©l√©charger le CSV tri√©</button>

            <div class="table-responsive">
                <table id="resultTable">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Titre</th>
                            <th>Artiste</th>
                            <th>BPM</th>
                            <th>Energy</th>
                            <th>Dance</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

    </div>

    <!-- MAIN SCRIPT -->
    <script>
        // --- LOGGING UTILS ---
        const debugLog = document.getElementById('debug-log');
        function log(msg) {
            console.log(msg);
            debugLog.style.display = 'block';
            debugLog.innerHTML += `<div>> ${msg}</div>`;
            debugLog.scrollTop = debugLog.scrollHeight;
        }

        // --- GLOBAL STATE ---
        let rawTracks = [];
        let chartInstance = null;
        let controlPoints = []; // Stores the state of our graph phases

        // --- INITIALIZATION ---
        window.onload = function () {
            log("System Loaded. Checking dependencies...");
            if (typeof Papa === 'undefined') {
                log("ERROR: PapaParse missing!");
                alert("Critical Error: Libraries failed to load.");
                return;
            }
            if (typeof Chart === 'undefined') {
                log("ERROR: Chart.js missing!");
            }
            log("Ready. Waiting for file...");
        };

        // --- STEP 1: CSV IMPORT ---
        document.getElementById('csvInput').addEventListener('change', function (evt) {
            const file = evt.target.files[0];
            if (!file) return;

            log(`File selected: ${file.name}`);
            document.getElementById('import-status').textContent = "Lecture en cours...";

            Papa.parse(file, {
                header: true,
                dynamicTyping: true, // Auto-convert numbers
                skipEmptyLines: true,
                complete: function (results) {
                    if (results.errors.length > 0) {
                        log("CSV Errors found: " + JSON.stringify(results.errors));
                    }

                    rawTracks = results.data;
                    log(`Parsed ${rawTracks.length} tracks.`);

                    if (rawTracks.length === 0) {
                        alert("Fichier vide ou malform√©.");
                        return;
                    }

                    document.getElementById('import-status').textContent = `‚úÖ ${rawTracks.length} titres charg√©s.`;
                    document.getElementById('import-status').style.color = 'green';

                    // Proceed to Step 2
                    document.getElementById('step-config').classList.remove('hidden');
                    initGraph();
                },
                error: function (err) {
                    log("Parse Error: " + err.message);
                    alert("Erreur de lecture du fichier.");
                }
            });
        });

        // --- STEP 2: GRAPH LOGIC (Using Chart.js with Drag Plugin simulation) ---
        // For simplicity and guaranteed robustness, we will simpler HTML5 Canvas logic or a simple Chart.js config.
        // Let's use a custom lightweight canvas implementation for maximum control like before, but cleaner.

        // Actually, simplified logic: A "Phase" is just an object. We render it with Chart.js for visuals? 
        // No, let's stick to the user's previous request for "Interactive Graph". 
        // I'll implement a VERY ROBUST pure Canvas graph to avoid library issues.

        const canvas = document.getElementById('flowChart');
        const ctx = canvas.getContext('2d');
        let isDragging = false;
        let dragInfo = null;

        function initGraph() {
            log("Initializing Graph...");
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;

            // Default Data: 5 Phases
            const numPhases = parseInt(document.getElementById('numPhases').value) || 5;
            controlPoints = [];

            for (let i = 0; i < numPhases; i++) {
                // Creates a default "Mountain" shape
                const progress = i / (numPhases - 1);
                controlPoints.push({
                    x: (i * (canvas.width / (numPhases - 1))), // Distributed evenly width-wise
                    energy: 0.3 + (Math.sin(progress * Math.PI) * 0.6), // 0.3 -> 0.9 -> 0.3
                    dance: 0.4 + (Math.sin(progress * Math.PI) * 0.4),
                    width: canvas.width / (numPhases - 1)
                });
            }

            draw();
            log("Graph interactive.");
        }

        document.getElementById('resetGraphBtn').onclick = initGraph;
        document.getElementById('numPhases').onchange = initGraph;

        // Draw Loop
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Grid
            ctx.strokeStyle = '#eee';
            ctx.beginPath();
            for (let i = 0; i <= 10; i++) {
                const y = i * (canvas.height / 10);
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
            }
            ctx.stroke();

            // Draw Lines
            drawCurve('energy', 'rgba(255, 99, 132, 1)', 3);
            drawCurve('dance', 'rgba(54, 162, 235, 1)', 3);

            // Draw Points
            controlPoints.forEach((p, i) => {
                const x = (i / (controlPoints.length - 1)) * (canvas.width - 40) + 20; // Re-calculate X dynamically
                p._screenX = x; // Cache for HitBox

                // Energy Point
                drawPoint(x, getY(p.energy), 'rgba(255, 99, 132, 1)');
                // Dance Point
                drawPoint(x, getY(p.dance), 'rgba(54, 162, 235, 1)');

                // Labels
                ctx.fillStyle = '#666';
                ctx.fillText(`P${i + 1}`, x - 5, canvas.height - 5);
            });
        }

        function getY(val) {
            return canvas.height - (val * canvas.height); // Flip Y
        }
        function getVal(y) {
            return 1 - (y / canvas.height);
        }

        function drawCurve(prop, color, width) {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            controlPoints.forEach((p, i) => {
                const x = p._screenX;
                const y = getY(p[prop]);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
        }

        function drawPoint(x, y, color) {
            ctx.beginPath();
            ctx.fillStyle = 'white';
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.arc(x, y, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
        }

        // Interaction
        canvas.addEventListener('mousedown', function (e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Find clicked point
            controlPoints.forEach((p, i) => {
                // Check Energy
                if (dist(mouseX, mouseY, p._screenX, getY(p.energy)) < 15) {
                    isDragging = true;
                    dragInfo = { index: i, prop: 'energy' };
                }
                // Check Dance
                if (dist(mouseX, mouseY, p._screenX, getY(p.dance)) < 15) {
                    isDragging = true;
                    dragInfo = { index: i, prop: 'dance' };
                }
            });
        });

        canvas.addEventListener('mousemove', function (e) {
            if (!isDragging || !dragInfo) return;
            const rect = canvas.getBoundingClientRect();
            const mouseY = e.clientY - rect.top;

            // Update value
            let newVal = getVal(mouseY);
            newVal = Math.max(0, Math.min(1, newVal)); // Clamp 0-1

            controlPoints[dragInfo.index][dragInfo.prop] = newVal;
            draw();
        });

        canvas.addEventListener('mouseup', () => { isDragging = false; dragInfo = null; });
        function dist(x1, y1, x2, y2) { return Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2); }


        // --- STEP 3: ALGORITHM ---
        document.getElementById('generateBtn').addEventListener('click', function () {
            log("Generating Playlist...");

            let pool = [...rawTracks];
            let finalPlaylist = [];

            // Simple logic: Divide playlist duration/count among phases
            // For this V0, let's just pick X songs per phase to match "Flow"

            const songsPerPhase = Math.floor(pool.length / controlPoints.length) || 1;

            controlPoints.forEach((phase, index) => {
                for (let k = 0; k < songsPerPhase; k++) {
                    if (pool.length === 0) break;

                    // Find best match in pool for this phase
                    let bestIdx = -1;
                    let bestDist = Infinity;

                    pool.forEach((track, tIdx) => {
                        // Safe parsing
                        const tEnergy = parseFloat(track.Energy) || 0.5;
                        const tDance = parseFloat(track.Danceability) || 0.5;

                        // Distance
                        const d = Math.sqrt(Math.pow(tEnergy - phase.energy, 2) + Math.pow(tDance - phase.dance, 2));

                        if (d < bestDist) {
                            bestDist = d;
                            bestIdx = tIdx;
                        }
                    });

                    if (bestIdx !== -1) {
                        finalPlaylist.push(pool[bestIdx]);
                        pool.splice(bestIdx, 1); // Remove used
                    }
                }
            });

            // Add remaining matches loosely or discard? Let's add them to the end for now
            // finalPlaylist.push(...pool); 

            log(`Playlist generated with ${finalPlaylist.length} tracks.`);
            renderTable(finalPlaylist);
            document.getElementById('step-results').classList.remove('hidden');
            document.getElementById('step-results').scrollIntoView({ behavior: 'smooth' });
        });

        function renderTable(tracks) {
            const tbody = document.querySelector('#resultTable tbody');
            tbody.innerHTML = '';

            tracks.forEach((t, i) => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${i + 1}</td>
                    <td>${t['Track Name'] || '???'}</td>
                    <td>${t['Artist Name(s)'] || ''}</td>
                    <td>${t.BPM || t.Tempo || ''}</td>
                    <td>${(t.Energy * 100).toFixed(0)}%</td>
                    <td>${(t.Danceability * 100).toFixed(0)}%</td>
                `;
                tbody.appendChild(tr);
            });

            // Setup Download
            document.getElementById('downloadBtn').onclick = function () {
                const csv = Papa.unparse(tracks);
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'playlist_V0.csv';
                a.click();
            };
        }

    </script>
</body>

</html>