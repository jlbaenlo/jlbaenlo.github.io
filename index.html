<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <title>Triateur de Playlists (V0 - Clean Rewrite)</title>
    <!-- External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>

    <style>
        :root {
            --spotify-green: #1DB954;
            --spotify-black: #191414;
            --light-grey: #f5f5f5;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--light-grey);
            color: #333;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            background: white;
            max-width: 900px;
            width: 100%;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: var(--spotify-green);
            text-align: center;
            margin-bottom: 10px;
        }

        .version {
            font-size: 0.6em;
            color: #666;
            vertical-align: middle;
        }

        /* Steps */
        .step {
            margin-bottom: 30px;
            padding: 20px;
            border-left: 4px solid var(--spotify-green);
            background: #fafafa;
            border-radius: 0 8px 8px 0;
        }

        .hidden {
            display: none;
        }

        /* Buttons */
        .btn {
            background-color: var(--spotify-green);
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 30px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.2s;
            text-decoration: none;
            display: inline-block;
        }

        .btn:hover {
            background-color: #1ed760;
            transform: scale(1.02);
        }

        .btn-secondary {
            background-color: #555;
        }

        /* Inputs */
        input[type="file"] {
            border: 2px dashed #ccc;
            padding: 20px;
            width: 100%;
            box-sizing: border-box;
            text-align: center;
            cursor: pointer;
        }

        /* Graph Container */
        .graph-container {
            position: relative;
            height: 400px;
            width: 100%;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: white;
            margin-top: 20px;
        }

        /* Table */
        .table-responsive {
            overflow-x: auto;
            margin-top: 20px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
        }

        th,
        td {
            padding: 10px;
            border-bottom: 1px solid #eee;
            text-align: left;
        }

        th {
            background-color: #f8f8f8;
        }

        /* Debug Box */
        #debug-log {
            font-family: monospace;
            font-size: 12px;
            background: #333;
            color: #0f0;
            padding: 10px;
            border-radius: 4px;
            margin-top: 20px;
            max-height: 150px;
            overflow-y: auto;
            display: none;
            /* Hidden by default */
        }
    </style>
</head>

<body>

    <div class="container">
        <h1>Triateur de Playlists ü™© <span class="version">(V1 - Advanced)</span></h1>

        <div style="text-align: center; margin-bottom: 20px;">
            <button onclick="window.location.reload()" class="btn btn-secondary"
                style="font-size: 0.8em; padding: 5px 15px;">
                ‚Üª Recharger l'app
            </button>
        </div>

        <!-- DEBUG LOG -->
        <div id="debug-log">Log system initiated...</div>

        <!-- STEP 1: IMPORT -->
        <div id="step-import" class="step">
            <h2>1. Import (CSV)</h2>
            <p>Exportez votre playlist depuis <a href="https://exportify.net" target="_blank">Exportify.net</a> (Format
                CSV) et glissez-la ici.</p>
            <input type="file" id="csvInput" accept=".csv" />
            <p id="import-status" style="margin-top: 10px; font-weight: bold;"></p>
        </div>

        <!-- STEP 2: CONFIG & GRAPH -->
        <div id="step-config" class="step hidden">
            <h2>2. Design Your Flow üåä</h2>

            <div style="background: #eee; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                <div style="display: flex; gap: 20px; align-items: flex-end; flex-wrap: wrap;">
                    <!-- Time Controls -->
                    <div>
                        <label style="font-size:12px; font-weight:bold;">D√©but</label><br>
                        <input type="time" id="startTime" value="21:00"
                            style="padding: 5px; border:1px solid #ccc; border-radius:4px;">
                    </div>
                    <div>
                        <label style="font-size:12px; font-weight:bold;">Fin</label><br>
                        <input type="time" id="endTime" value="23:00"
                            style="padding: 5px; border:1px solid #ccc; border-radius:4px;">
                    </div>
                    <div style="font-size: 14px; font-weight: bold; color: var(--spotify-green); padding-bottom: 5px;">
                        Dur√©e: <span id="totalDurationLabel">2h 00m</span>
                    </div>

                    <!-- Preset Selector -->
                    <div style="margin-left: auto;">
                        <label style="font-size:12px; font-weight:bold;">Mode</label><br>
                        <select id="flowMode" style="padding: 6px; border-radius:4px; min-width: 120px;">
                            <option value="custom">üõ†Ô∏è Custom</option>
                            <option value="party" selected>üéâ Party (Standard)</option>
                            <option value="apero">üç∑ Ap√©ro (Chill)</option>
                            <option value="sport">üí™ Sport (Intensity)</option>
                        </select>
                    </div>

                    <div>
                        <label style="font-size:12px; font-weight:bold;">Phases</label><br>
                        <input type="number" id="numPhases" value="5" min="2" max="10"
                            style="width: 50px; padding: 5px;">
                    </div>

                    <button id="resetGraphBtn" class="btn btn-secondary"
                        style="padding: 6px 12px; font-size: 12px;">Reset</button>
                </div>
            </div>

            <p class="small" style="margin-bottom: 5px;">
                üñ±Ô∏è <b>Drag</b> les points pour l'intensit√©. ‚ÜîÔ∏è <b>Drag</b> les lignes verticales pour changer la dur√©e.
            </p>
            <div class="graph-container">
                <canvas id="flowChart"></canvas>
            </div>
            <div style="display: flex; justify-content: center; gap: 15px; font-size: 13px; margin-top: 5px;">
                <span style="color:rgba(255, 99, 132, 1)">‚óè Energy</span>
                <span style="color:rgba(54, 162, 235, 1)">‚óè Danceability</span>
            </div>

            <div style="text-align: center; margin-top: 30px;">
                <button id="generateBtn" class="btn">üöÄ G√©n√©rer la Playlist</button>
            </div>
        </div>

        <!-- STEP 3: RESULTS -->
        <div id="step-results" class="step hidden">
            <h2>3. R√©sultats</h2>
            <p id="result-summary"></p>
            <button id="downloadBtn" class="btn">üì• T√©l√©charger le CSV tri√©</button>

            <div class="table-responsive">
                <table id="resultTable">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Titre</th>
                            <th>Artiste</th>
                            <th>BPM</th>
                            <th>Energy</th>
                            <th>Dance</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

    </div>

    <!-- MAIN SCRIPT -->
    <script>
        // --- UTILS ---
        const debugLog = document.getElementById('debug-log');
        function log(msg) {
            console.log(msg);
            debugLog.style.display = 'block';
            debugLog.innerHTML += `<div>> ${msg}</div>`;
            debugLog.scrollTop = debugLog.scrollHeight;
        }

        // --- GLOBAL STATE ---
        let rawTracks = [];
        // Phases State: { id, energy, dance, durationPercent, startPercent }
        // Note: startPercent is derived from durationPercent of previous items.
        // It is easier to store `durationPercent` as the source of truth.
        let phases = [];
        let totalTimeMinutes = 120; // Default 2h

        // --- INITIALIZATION ---
        window.onload = function () {
            log("System Loading (V1 - Advanced)...");
            if (typeof Papa === 'undefined') {
                log("ERROR: PapaParse missing!");
                alert("Critical Error: Libraries failed to load.");
            }
            updateTimeCalculations();
        };

        // --- TIMING LOGIC ---
        const startTimeEl = document.getElementById('startTime');
        const endTimeEl = document.getElementById('endTime');
        const durationLabel = document.getElementById('totalDurationLabel');

        function updateTimeCalculations() {
            const start = startTimeEl.value; // "HH:MM"
            const end = endTimeEl.value;

            const [sh, sm] = start.split(':').map(Number);
            const [eh, em] = end.split(':').map(Number);

            let sMin = sh * 60 + sm;
            let eMin = eh * 60 + em;

            if (eMin < sMin) eMin += 24 * 60; // Overnight

            totalTimeMinutes = eMin - sMin;
            const h = Math.floor(totalTimeMinutes / 60);
            const m = totalTimeMinutes % 60;

            durationLabel.textContent = `${h}h ${m.toString().padStart(2, '0')}m`;
            if (phases.length > 0) draw(); // Redraw graph labels
        }

        startTimeEl.addEventListener('change', updateTimeCalculations);
        endTimeEl.addEventListener('change', updateTimeCalculations);

        // --- STEP 1: IMPORT ---
        document.getElementById('csvInput').addEventListener('change', function (evt) {
            const file = evt.target.files[0];
            if (!file) return;

            log(`File: ${file.name}`);
            document.getElementById('import-status').textContent = "Lecture...";

            Papa.parse(file, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function (results) {
                    rawTracks = results.data;
                    document.getElementById('import-status').textContent = `‚úÖ ${rawTracks.length} titres.`;
                    document.getElementById('step-config').classList.remove('hidden');
                    initGraph();
                }
            });
        });

        // --- STEP 2: ADVANCED GRAPH ---
        const canvas = document.getElementById('flowChart');
        const ctx = canvas.getContext('2d');
        let isDragging = false;
        let dragTarget = null; // { type: 'point'|'separator', index: 0, prop: 'energy' }

        // Presets
        const PRESETS = {
            custom: () => [], // Handled by generic
            party: (n) => {
                // Warmup -> Build -> Peak -> Sustain -> Cool
                // Ideal for 5 phases
                return [
                    { d: 0.15, e: 0.3, da: 0.4 }, // Warmup
                    { d: 0.25, e: 0.6, da: 0.6 }, // Build
                    { d: 0.25, e: 0.9, da: 0.9 }, // Peak
                    { d: 0.20, e: 0.8, da: 0.8 }, // Sustain
                    { d: 0.15, e: 0.4, da: 0.5 }  // Cool
                ];
            },
            apero: (n) => {
                // Chill & Consistent
                let p = [];
                for (let i = 0; i < n; i++) p.push({ d: 1 / n, e: 0.4, da: 0.5 + (i % 2) * 0.1 });
                return p;
            },
            sport: (n) => {
                // High Energy Interval
                return [
                    { d: 0.1, e: 0.5, da: 0.5 },
                    { d: 0.4, e: 0.9, da: 0.8 },
                    { d: 0.4, e: 0.8, da: 0.8 },
                    { d: 0.1, e: 0.4, da: 0.4 }
                ];
            }
        };

        function initGraph() {
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;

            const numPhases = parseInt(document.getElementById('numPhases').value) || 5;
            const mode = document.getElementById('flowMode').value;

            phases = [];

            if (mode !== 'custom' && PRESETS[mode]) {
                const presetData = PRESETS[mode](numPhases);
                // Adapt preset to current numPhases if needed
                if (presetData.length === numPhases) {
                    phases = presetData.map(p => ({ durationPercent: p.d, energy: p.e, dance: p.da }));
                } else {
                    // Fallback: fill generic
                    const baseW = 1 / numPhases;
                    for (let i = 0; i < numPhases; i++) phases.push({ durationPercent: baseW, energy: 0.5, dance: 0.5 });
                }
            }

            // Generic fill if empty (or custom)
            if (phases.length === 0) {
                const baseW = 1 / numPhases;
                for (let i = 0; i < numPhases; i++) {
                    phases.push({
                        durationPercent: baseW,
                        energy: 0.5 + (Math.sin(i / numPhases * Math.PI) * 0.4),
                        dance: 0.5 + (Math.sin(i / numPhases * Math.PI) * 0.3)
                    });
                }
            }

            // Normalize Duration just in case
            normalizeDurations();
            draw();
        }

        document.getElementById('resetGraphBtn').onclick = initGraph;
        document.getElementById('numPhases').onchange = initGraph;
        document.getElementById('flowMode').onchange = function () {
            // Update numPhases if preset implies it? No, keep user control or hint?
            // For now just re-init
            if (this.value === 'party') document.getElementById('numPhases').value = 5;
            if (this.value === 'sport') document.getElementById('numPhases').value = 4;
            initGraph();
        };

        function normalizeDurations() {
            const total = phases.reduce((acc, p) => acc + p.durationPercent, 0);
            phases.forEach(p => p.durationPercent /= total);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const w = canvas.width;
            const h = canvas.height;
            const padding = 30; // Bottom padding for labels

            // Background Grid
            ctx.strokeStyle = '#f0f0f0';
            ctx.beginPath();
            for (let i = 0; i <= 4; i++) {
                let y = i * (h - padding) / 4;
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
            }
            ctx.stroke();

            // Calculate Start X for each phase
            let currentXPct = 0;
            const phaseMeta = []; // Store calculated coordinates for interaction

            phases.forEach((p, i) => {
                const startX = currentXPct * w;
                const phaseW = p.durationPercent * w;
                const centerX = startX + (phaseW / 2);

                phaseMeta.push({
                    i: i,
                    startX: startX,
                    endX: startX + phaseW,
                    centerX: centerX,
                    centerY_E: (1 - p.energy) * (h - padding),
                    centerY_D: (1 - p.dance) * (h - padding)
                });

                // Draw Separator (if not last)
                if (i < phases.length - 1) {
                    ctx.beginPath();
                    ctx.strokeStyle = '#ccc';
                    ctx.setLineDash([5, 5]);
                    ctx.moveTo(startX + phaseW, 0);
                    ctx.lineTo(startX + phaseW, h - padding);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Separator Handle
                    ctx.fillStyle = '#ddd';
                    ctx.fillRect(startX + phaseW - 3, h / 2 - 10, 6, 20);
                }

                currentXPct += p.durationPercent;
            });

            // Store meta for drag hits
            canvas.phaseMeta = phaseMeta;

            // Draw Lines & Points
            drawCurve(phaseMeta, 'energy', 'centerY_E', 'rgba(255, 99, 132, 1)');
            drawCurve(phaseMeta, 'dance', 'centerY_D', 'rgba(54, 162, 235, 1)');

            // Draw Time Labels (X-axis)
            ctx.fillStyle = '#666';
            ctx.font = '10px monospace';
            ctx.textAlign = 'center';

            // Start Time
            ctx.fillText(document.getElementById('startTime').value, 0 + 20, h - 10);

            // Phase Times
            let timeAccum = 0;
            const [sh, sm] = document.getElementById('startTime').value.split(':').map(Number);
            const refStartMin = sh * 60 + sm;

            phases.forEach((p, i) => {
                timeAccum += p.durationPercent * totalTimeMinutes;
                if (i < phases.length - 1) {
                    // Separator Time
                    const minVal = Math.floor(refStartMin + timeAccum);
                    const labelH = Math.floor((minVal / 60) % 24);
                    const labelM = Math.floor(minVal % 60);
                    const label = `${labelH}:${labelM.toString().padStart(2, '0')}`;

                    const x = phaseMeta[i].endX;
                    ctx.fillText(label, x, h - 10);
                }
            });

            // End Time
            ctx.fillText(document.getElementById('endTime').value, w - 20, h - 10);
        }

        function drawCurve(meta, prop, yProp, color) {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;

            meta.forEach((m, i) => {
                const x = m.centerX;
                const y = m[yProp];
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();

            // Points
            meta.forEach(m => {
                const x = m.centerX;
                const y = m[yProp];

                ctx.beginPath();
                ctx.arc(x, y, 6, 0, Math.PI * 2);
                ctx.fillStyle = 'white';
                ctx.fill();
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }

        // --- INTERACTION ---
        canvas.addEventListener('mousedown', e => {
            const r = canvas.getBoundingClientRect();
            const mx = e.clientX - r.left;
            const my = e.clientY - r.top;
            const meta = canvas.phaseMeta;

            if (!meta) return;

            // 1. Check Separators
            for (let i = 0; i < meta.length - 1; i++) {
                const sepX = meta[i].endX;
                if (Math.abs(mx - sepX) < 10) {
                    isDragging = true;
                    dragTarget = { type: 'separator', index: i };
                    return;
                }
            }

            // 2. Check Points
            // Reverse order to pick top element
            for (let i = 0; i < meta.length; i++) {
                // Dance
                if (Math.hypot(mx - meta[i].centerX, my - meta[i].centerY_D) < 10) {
                    isDragging = true;
                    dragTarget = { type: 'point', index: i, prop: 'dance' };
                    return;
                }
                // Energy
                if (Math.hypot(mx - meta[i].centerX, my - meta[i].centerY_E) < 10) {
                    isDragging = true;
                    dragTarget = { type: 'point', index: i, prop: 'energy' };
                    return;
                }
            }
        });

        canvas.addEventListener('mousemove', e => {
            const r = canvas.getBoundingClientRect();
            const mx = e.clientX - r.left;
            const my = e.clientY - r.top;

            // Cursor hint
            let cursor = 'default';
            if (canvas.phaseMeta) {
                // Check separators
                for (let i = 0; i < canvas.phaseMeta.length - 1; i++) {
                    if (Math.abs(mx - canvas.phaseMeta[i].endX) < 10) cursor = 'col-resize';
                }
            }
            canvas.style.cursor = cursor;

            if (!isDragging || !dragTarget) return;

            if (dragTarget.type === 'point') {
                const h = canvas.height - 30; // padding
                let val = 1 - (my / h);
                val = Math.max(0, Math.min(1, val));
                phases[dragTarget.index][dragTarget.prop] = val;
            }
            else if (dragTarget.type === 'separator') {
                // Dragging separator i implies adjusting width of i and i+1
                const i = dragTarget.index;
                const meta = canvas.phaseMeta;

                // Calculate new split based on pixels
                const startX = meta[i].startX;
                const endX = meta[i + 1].endX; // Total width shared by both

                // New width of left phase (i)
                let newWPx = mx - startX;
                const totalWPx = endX - startX;

                // Constraints (min 20px)
                if (newWPx < 20) newWPx = 20;
                if (newWPx > totalWPx - 20) newWPx = totalWPx - 20;

                const newRatio = newWPx / totalWPx;

                // Their combined duration percent
                const combinedPct = phases[i].durationPercent + phases[i + 1].durationPercent;

                phases[i].durationPercent = combinedPct * newRatio;
                phases[i + 1].durationPercent = combinedPct * (1 - newRatio);
            }

            draw();
        });

        canvas.addEventListener('mouseup', () => { isDragging = false; dragTarget = null; });


        // --- STEP 3: GENERATION (Duration Based) ---
        document.getElementById('generateBtn').addEventListener('click', function () {
            log("Computing Playlist (Time Based)...");

            let pool = [...rawTracks];
            let playlist = [];
            let currentDurMs = 0;
            const totalDurMs = totalTimeMinutes * 60000;

            phases.forEach((p, i) => {
                const phaseTargetDur = totalDurMs * p.durationPercent;
                let phaseCurrentDur = 0;

                log(`Allocating Phase ${i + 1}: Target ${(phaseTargetDur / 60000).toFixed(1)}m`);

                // Try to fill this duration
                while (phaseCurrentDur < phaseTargetDur && pool.length > 0) {
                    // Find best match
                    let bestIdx = -1;
                    let bestScore = Infinity;

                    // Optimization: Don't scan huge list every time if slow. But 500-1000 items is fine.
                    for (let k = 0; k < pool.length; k++) {
                        const t = pool[k];
                        const tE = t.Energy || 0.5;
                        const tD = t.Danceability || 0.5;

                        const dist = Math.sqrt((tE - p.energy) ** 2 + (tD - p.dance) ** 2);
                        if (dist < bestScore) {
                            bestScore = dist;
                            bestIdx = k;
                        }
                    }

                    if (bestIdx !== -1) {
                        const track = pool[bestIdx];
                        const tDur = track['Duration (ms)'] || 200000;

                        // Check overload? Maybe allow one track overflow to avoid holes
                        playlist.push(track);
                        pool.splice(bestIdx, 1);

                        phaseCurrentDur += tDur;
                        currentDurMs += tDur;
                    } else {
                        break;
                    }
                }
            });

            log(`Generation done. Total: ${(currentDurMs / 60000).toFixed(1)}m`);
            renderTable(playlist);
            document.getElementById('step-results').classList.remove('hidden');
            document.getElementById('step-results').scrollIntoView({ behavior: 'smooth' });
        });

        function renderTable(tracks) {
            const tbody = document.querySelector('#resultTable tbody');
            tbody.innerHTML = '';

            tracks.forEach((t, i) => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${i + 1}</td>
                    <td>${t['Track Name'] || '???'}</td>
                    <td>${t['Artist Name(s)'] || ''}</td>
                    <td>${t.BPM || t.Tempo || ''}</td>
                    <td>${parseFloat(t.Energy).toFixed(2)}</td>
                    <td>${parseFloat(t.Danceability).toFixed(2)}</td>
                `;
                tbody.appendChild(tr);
            });

            document.getElementById('downloadBtn').onclick = function () {
                const csv = Papa.unparse(tracks);
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'playlist_final.csv';
                a.click();
            };
        }

    </script>
</body>

</html>