<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8" />
    <title>Triateur de Playlists Spotify (PKCE)</title>
    <style>
        body {
            font-family: Arial;
            padding: 20px;
        }

        button {
            padding: 10px 15px;
            margin: 10px 0;
        }

        select {
            padding: 5px;
            width: 300px;
        }

        .error {
            background: #ffcccc;
            border: 1px solid red;
            padding: 10px;
            margin: 10px 0;
            display: none;
        }
    </style>
</head>

<body>

    <h1>Triateur de Playlists Spotify ü™©</h1>
    <p>1. Connectez-vous<br>2. Choisissez une playlist<br>3. Cliquez pour cr√©er une version tri√©e</p>

    <!-- ERROR DISPLAY -->
    <div id="errorDisplay" class="error">
        <h3 style="color: red; margin-top: 0;">‚ùå Erreur</h3>
        <p id="errorDetails"></p>
    </div>

    <button id="loginBtn">Se connecter avec Spotify</button>

    <div id="app" style="display:none;">
        <h3>Vos playlists :</h3>
        <select id="playlistSelect"></select>
        <br><br>
        <button id="sortBtn">Cr√©er playlist tri√©e</button>
        <p id="status"></p>
    </div>

    <script>
        // ------------------------------------------------------
        // CONFIGURATION
        // ------------------------------------------------------
        const CLIENT_ID = "1795fe450d3a4f6ebe2ce1cdcfbc21bf";

        // DYNAMIC REDIRECT URI
        let redirectUri = window.location.origin + window.location.pathname;
        if (redirectUri.endsWith("index.html")) {
            redirectUri = redirectUri.substring(0, redirectUri.length - "index.html".length);
        }
        if (!redirectUri.endsWith("/") && !redirectUri.endsWith(".html")) {
            redirectUri += "/";
        }

        let accessToken = null;

        // ------------------------------------------------------
        // PKCE HELPERS
        // ------------------------------------------------------
        function generateRandomString(length) {
            let text = '';
            const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            for (let i = 0; i < length; i++) {
                text += possible.charAt(Math.floor(Math.random() * possible.length));
            }
            return text;
        }

        async function generateCodeChallenge(codeVerifier) {
            const data = new TextEncoder().encode(codeVerifier);
            const digest = await window.crypto.subtle.digest('SHA-256', data);
            return btoa(String.fromCharCode.apply(null, [...new Uint8Array(digest)]))
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=+$/, '');
        }

        // ------------------------------------------------------
        // AUTHENTICATION LOGIC
        // ------------------------------------------------------

        // 1. CHECK FOR ERROR
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('error')) {
            document.getElementById("errorDisplay").style.display = "block";
            document.getElementById("errorDetails").textContent = urlParams.get('error');
        }

        // 2. CHECK FOR CODE (AFTER LOGIN)
        const code = urlParams.get('code');
        if (code) {
            exchangeCodeForToken(code);
        }

        async function exchangeCodeForToken(code) {
            const codeVerifier = localStorage.getItem('code_verifier');

            try {
                const response = await fetch('https://accounts.spotify.com/api/token', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: new URLSearchParams({
                        client_id: CLIENT_ID,
                        grant_type: 'authorization_code',
                        code: code,
                        redirect_uri: redirectUri,
                        code_verifier: codeVerifier,
                    }),
                });

                if (!response.ok) {
                    const data = await response.json();
                    throw new Error(JSON.stringify(data));
                }

                const data = await response.json();
                accessToken = data.access_token;

                // UI UPDATE
                document.getElementById("loginBtn").style.display = "none";
                document.getElementById("app").style.display = "block";

                // Clean URL
                window.history.replaceState({}, document.title, "/");

                // LOAD APP DATA
                loadPlaylists();

            } catch (err) {
                alert("Erreur lors de l'√©change du token : " + err);
            }
        }

        // 3. START LOGIN
        document.getElementById("loginBtn").onclick = async function () {
            const codeVerifier = generateRandomString(128);
            const codeChallenge = await generateCodeChallenge(codeVerifier);
            localStorage.setItem('code_verifier', codeVerifier);

            // Ajout de scopes standards pour √©viter les soucis de permissions
            const scope = "user-read-private user-read-email user-read-playback-state playlist-read-private playlist-modify-private playlist-modify-public";
            const authUrl = "https://accounts.spotify.com/authorize" +
                `?client_id=${CLIENT_ID}` +
                `&response_type=code` +
                `&redirect_uri=${encodeURIComponent(redirectUri)}` +
                `&scope=${encodeURIComponent(scope)}` +
                `&code_challenge=${codeChallenge}` +
                `&code_challenge_method=S256` +
                `&show_dialog=true`;
            window.location = authUrl;
        };

        // ------------------------------------------------------
        // APPLICATION LOGIC (PLAYLISTS)
        // ------------------------------------------------------
        async function loadPlaylists() {
            const resp = await fetch("https://api.spotify.com/v1/me/playlists", {
                headers: { Authorization: "Bearer " + accessToken }
            });
            const data = await resp.json();

            const select = document.getElementById("playlistSelect");
            data.items.forEach(pl => {
                const opt = document.createElement("option");
                opt.value = pl.id;
                opt.textContent = pl.name;
                select.appendChild(opt);
            });
        }

        document.getElementById("sortBtn").onclick = async () => {
            const playlistId = document.getElementById("playlistSelect").value;
            const statusEl = document.getElementById("status");
            statusEl.textContent = "R√©cup√©ration de la playlist‚Ä¶";
            statusEl.style.color = "black";

            try {
                console.log("Starting sort for playlist:", playlistId);

                // 1. R√©cup√©rer les morceaux
                const tracksResp = await fetch(`https://api.spotify.com/v1/playlists/${playlistId}/tracks`, {
                    headers: { Authorization: "Bearer " + accessToken }
                });
                if (!tracksResp.ok) throw new Error("Erreur fetch tracks: " + tracksResp.status);
                const tracks = await tracksResp.json();
                console.log("Tracks fetched:", tracks);

                if (!tracks.items || tracks.items.length === 0) {
                    throw new Error("Cette playlist est vide !");
                }

                // FILTRAGE DES TRACKS VALIDES (Pas de fichiers locaux, pas de null)
                const validTracks = tracks.items.filter(t => t.track && t.track.id);

                if (validTracks.length === 0) {
                    throw new Error("Aucun morceau valide trouv√© (peut-√™tre que des fichiers locaux ?)");
                }

                console.log(`Found ${validTracks.length} valid tracks out of ${tracks.items.length}`);

                // 2. R√©cup√©rer l'audio features
                // Note: Spotify API limit is 100 IDs per request. For simplicity, we take the first 100.
                const tracksToProcess = validTracks.slice(0, 100);
                const ids = tracksToProcess.map(t => t.track.id).join(",");

                const audioResp = await fetch(`https://api.spotify.com/v1/audio-features?ids=${ids}`, {
                    headers: { Authorization: "Bearer " + accessToken }
                });

                if (!audioResp.ok) {
                    // Debug plus pr√©cis
                    const errBody = await audioResp.text();
                    console.error("Audio Features Error Body:", errBody);
                    throw new Error("Erreur audio features: " + audioResp.status);
                }

                const audio = await audioResp.json();
                console.log("Audio features fetched:", audio);

                // 3. Trier
                // Attention: audio.audio_features peut contenir des nulls si un ID est invalide
                const sorted = [];
                for (let i = 0; i < audio.audio_features.length; i++) {
                    const feature = audio.audio_features[i];
                    const track = tracksToProcess[i];
                    if (feature) {
                        sorted.push({
                            uri: track.track.uri,
                            danceability: feature.danceability
                        });
                    } else {
                        // Si pas de feature, on le met √† la fin ou on le garde tel quel
                        sorted.push({
                            uri: track.track.uri,
                            danceability: 0
                        });
                    }
                }

                sorted.sort((a, b) => a.danceability - b.danceability);

                statusEl.textContent = "Cr√©ation de la nouvelle playlist‚Ä¶";

                // 4. Cr√©er playlist
                const meResp = await fetch("https://api.spotify.com/v1/me", {
                    headers: { Authorization: "Bearer " + accessToken }
                });
                if (!meResp.ok) throw new Error("Erreur fetch me: " + meResp.status);
                const me = await meResp.json();

                const newPlaylistResp = await fetch(`https://api.spotify.com/v1/users/${me.id}/playlists`, {
                    method: "POST",
                    headers: {
                        Authorization: "Bearer " + accessToken,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        name: "Playlist Tri√©e üíø",
                        description: "Cr√©√©e automatiquement par Triateur",
                        public: false
                    })
                });
                if (!newPlaylistResp.ok) throw new Error("Erreur cr√©ation playlist: " + newPlaylistResp.status);
                const newPlaylist = await newPlaylistResp.json();

                // 5. Ajouter morceaux
                const addTracksResp = await fetch(`https://api.spotify.com/v1/playlists/${newPlaylist.id}/tracks`, {
                    method: "POST",
                    headers: {
                        Authorization: "Bearer " + accessToken,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        uris: sorted.map(s => s.uri)
                    })
                });
                if (!addTracksResp.ok) throw new Error("Erreur ajout tracks: " + addTracksResp.status);

                statusEl.textContent = "üéâ Playlist tri√©e cr√©√©e : " + newPlaylist.name;
                statusEl.style.color = "green";

            } catch (err) {
                console.error(err);
                statusEl.textContent = "‚ùå Erreur : " + err.message;
                statusEl.style.color = "red";
            }
        };
    </script>
</body>

</html>